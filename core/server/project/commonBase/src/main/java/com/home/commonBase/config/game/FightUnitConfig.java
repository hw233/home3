package com.home.commonBase.config.game;
import com.home.commonBase.config.base.BaseConfig;
import com.home.commonBase.config.game.enumT.SkillInfluenceTypeConfig;
import com.home.shine.bytes.BytesReadStream;
import com.home.shine.bytes.BytesWriteStream;
import com.home.shine.support.collection.IntObjectMap;
import com.home.shine.support.collection.SMap;
import com.home.shine.utils.MathUtils;

/** 战斗单位表(generated by shine) */
public class FightUnitConfig extends BaseConfig
{
	/** 存储集合 */
	private static IntObjectMap<FightUnitConfig> _dic;
	
	/** id */
	public int id;
	
	/** 攻击距离类型 */
	public int attackRange;
	
	/** 模型ID */
	public int modelID;
	
	/** 所属组 */
	public int[] groups;
	
	/** 死亡保留时间(ms) */
	public int deathKeepTime;
	
	/** 复活等待时间(ms) */
	public int reviveWaitTime;
	
	/** 所属职业 */
	public int vocation;
	
	/** 默认AI指令 */
	public int defaultAICommand;
	
	/** 默认AI模式 */
	public int defaultAIMode;
	
	/** 是否在待机状态下游荡 */
	public boolean isWanderOnIdle;
	
	/** 被动攻击半径 */
	public float passiveAttackRadius;
	
	/** 被动攻击半径平方 */
	public float passiveAttackRadiusT;
	
	/** 主动攻击半径 */
	public float initiativeAttackRadius;
	
	/** 主动攻击半径平方 */
	public float initiativeAttackRadiusT;
	
	/** 最大追击半径 */
	public float maxPursueRadius;
	
	/** 唤醒同伴半径 */
	public float wakeUpCompanionAttackRadius;
	
	/** 唤醒同伴半径 */
	public float wakeUpCompanionAttackRadiusT;
	
	/** 跟随攻击半径平方 */
	public float followAttackRadiusT;
	
	/** 跟随半径 */
	public float followRadius;
	
	/** 驾驶方式转向角速度(角度/s) */
	public float driveAngleSpeed;
	
	/** 驾驶方式转向角速度(弧度/ms) */
	public float driveDirectionSpeedT;
	
	/** 驾驶方式转向半径 */
	public float driveTurnRadius;
	
	/** 跟随半径平方 */
	public float followRadiusT;
	
	/** 驾驶方式是否可原地转向 */
	public boolean canDriveTurnAtPivot;
	
	/** 可攻击目标类型 */
	public int[] attackInfluenceType;
	
	/** 地图移动类型 */
	public int mapMoveType;
	
	/** 走跑移速比率 */
	public float walkSpeedRatio;
	
	/** 是否启用仇恨目标切换 */
	public boolean needHateSwitchTarget;
	
	/** 是否使用驾驶方式移动 */
	public boolean needDrive;
	
	/** 驾驶方式加速度 */
	public int driveAccelerateSpeed;
	
	/** 可攻击目标类型 */
	public boolean[] attackInfluenceTypeT;
	
	/** 复活方式 */
	public int reviveType;
	
	/** 等级上限 */
	public int levelMax;
	
	/** 获取 */
	public static FightUnitConfig get(int id)
	{
		return _dic.get(id);
	}
	
	/** 设置字典 */
	public static void setDic(IntObjectMap<FightUnitConfig> dic)
	{
		_dic=dic;
	}
	
	/** 获取全部 */
	public static IntObjectMap<FightUnitConfig> getDic()
	{
		return _dic;
	}
	
	/** 读取字节流(简版) */
	@Override
	protected void toReadBytesSimple(BytesReadStream stream)
	{
		super.toReadBytesSimple(stream);
		
		this.id=stream.readInt();
		
		this.attackRange=stream.readInt();
		
		this.modelID=stream.readInt();
		
		this.vocation=stream.readInt();
		
		int groupsLen=stream.readLen();
		if(this.groups==null || this.groups.length!=groupsLen)
		{
			this.groups=new int[groupsLen];
		}
		int[] groupsT=this.groups;
		for(int groupsI=0;groupsI<groupsLen;++groupsI)
		{
			int groupsV;
			groupsV=stream.readInt();
			
			groupsT[groupsI]=groupsV;
		}
		
		this.deathKeepTime=stream.readInt();
		
		this.reviveWaitTime=stream.readInt();
		
		this.reviveType=stream.readInt();
		
		this.isWanderOnIdle=stream.readBoolean();
		
		this.defaultAIMode=stream.readInt();
		
		this.defaultAICommand=stream.readInt();
		
		this.initiativeAttackRadius=stream.readFloat();
		
		this.passiveAttackRadius=stream.readFloat();
		
		this.maxPursueRadius=stream.readFloat();
		
		this.wakeUpCompanionAttackRadius=stream.readFloat();
		
		this.followRadius=stream.readFloat();
		
		int attackInfluenceTypeLen=stream.readLen();
		if(this.attackInfluenceType==null || this.attackInfluenceType.length!=attackInfluenceTypeLen)
		{
			this.attackInfluenceType=new int[attackInfluenceTypeLen];
		}
		int[] attackInfluenceTypeT=this.attackInfluenceType;
		for(int attackInfluenceTypeI=0;attackInfluenceTypeI<attackInfluenceTypeLen;++attackInfluenceTypeI)
		{
			int attackInfluenceTypeV;
			attackInfluenceTypeV=stream.readInt();
			
			attackInfluenceTypeT[attackInfluenceTypeI]=attackInfluenceTypeV;
		}
		
		this.mapMoveType=stream.readInt();
		
		this.walkSpeedRatio=stream.readFloat();
		
		this.needDrive=stream.readBoolean();
		
		this.driveAngleSpeed=stream.readFloat();
		
		this.driveAccelerateSpeed=stream.readInt();
		
		this.driveTurnRadius=stream.readFloat();
		
		this.canDriveTurnAtPivot=stream.readBoolean();
		
		this.needHateSwitchTarget=stream.readBoolean();
		
	}
	
	@Override
	protected void afterReadConfig()
	{
		super.afterReadConfig();
		
		initiativeAttackRadiusT=initiativeAttackRadius*initiativeAttackRadius;
		passiveAttackRadiusT=passiveAttackRadius*passiveAttackRadius;
		followRadiusT=followRadius*followRadius;
		wakeUpCompanionAttackRadiusT=wakeUpCompanionAttackRadius*wakeUpCompanionAttackRadius;
		attackInfluenceTypeT=SkillInfluenceTypeConfig.getInfluenceSet(attackInfluenceType);
		driveDirectionSpeedT=MathUtils.angleToDirection(driveAngleSpeed)/1000f;
	}
	
	/** 读完所有表后处理 */
	public static void afterReadConfigAll()
	{
	
	}
	
	/** 写入字节流(简版) */
	@Override
	protected void toWriteBytesSimple(BytesWriteStream stream)
	{
		super.toWriteBytesSimple(stream);
		
		stream.writeInt(this.id);
		
		stream.writeInt(this.attackRange);
		
		stream.writeInt(this.modelID);
		
		stream.writeInt(this.vocation);
		
		if(this.groups!=null)
		{
			int[] groupsT=this.groups;
			stream.writeLen(groupsT.length);
			for(int groupsVI=0,groupsVLen=groupsT.length;groupsVI<groupsVLen;++groupsVI)
			{
				int groupsV=groupsT[groupsVI];
				stream.writeInt(groupsV);
				
			}
		}
		else
		{
			nullObjError("groups");
		}
		
		stream.writeInt(this.deathKeepTime);
		
		stream.writeInt(this.reviveWaitTime);
		
		stream.writeInt(this.reviveType);
		
		stream.writeBoolean(this.isWanderOnIdle);
		
		stream.writeInt(this.defaultAIMode);
		
		stream.writeInt(this.defaultAICommand);
		
		stream.writeFloat(this.initiativeAttackRadius);
		
		stream.writeFloat(this.passiveAttackRadius);
		
		stream.writeFloat(this.maxPursueRadius);
		
		stream.writeFloat(this.wakeUpCompanionAttackRadius);
		
		stream.writeFloat(this.followRadius);
		
		if(this.attackInfluenceType!=null)
		{
			int[] attackInfluenceTypeT=this.attackInfluenceType;
			stream.writeLen(attackInfluenceTypeT.length);
			for(int attackInfluenceTypeVI=0,attackInfluenceTypeVLen=attackInfluenceTypeT.length;attackInfluenceTypeVI<attackInfluenceTypeVLen;++attackInfluenceTypeVI)
			{
				int attackInfluenceTypeV=attackInfluenceTypeT[attackInfluenceTypeVI];
				stream.writeInt(attackInfluenceTypeV);
				
			}
		}
		else
		{
			nullObjError("attackInfluenceType");
		}
		
		stream.writeInt(this.mapMoveType);
		
		stream.writeFloat(this.walkSpeedRatio);
		
		stream.writeBoolean(this.needDrive);
		
		stream.writeFloat(this.driveAngleSpeed);
		
		stream.writeInt(this.driveAccelerateSpeed);
		
		stream.writeFloat(this.driveTurnRadius);
		
		stream.writeBoolean(this.canDriveTurnAtPivot);
		
		stream.writeBoolean(this.needHateSwitchTarget);
		
	}
	
	/** 是否包含某组 */
	public boolean hasGroup(int groupID)
	{
		int[] groups;
		
		for(int i=(groups=this.groups).length-1;i>=0;--i)
		{
			if(groups[i]==groupID)
				return true;
		}
		
		return false;
	}
	
}
