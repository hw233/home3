package com.home.commonBase.config.game;
import com.home.commonBase.config.base.BaseConfig;
import com.home.commonBase.config.game.enumT.SkillInfluenceTypeConfig;
import com.home.shine.bytes.BytesReadStream;
import com.home.shine.bytes.BytesWriteStream;
import com.home.shine.support.collection.IntObjectMap;
import com.home.shine.support.collection.SMap;

/** 战斗单位表(generated by shine) */
public class FightUnitConfig extends BaseConfig
{
	/** 存储集合 */
	private static IntObjectMap<FightUnitConfig> _dic;
	
	/** id */
	public int id;
	
	/** 攻击距离类型 */
	public int attackRange;
	
	/** 模型ID */
	public int modelID;
	
	/** 死亡保留时间(ms) */
	public int deathKeepTime;
	
	/** 复活等待时间(ms) */
	public int reviveWaitTime;
	
	/** 所属职业 */
	public int vocation;
	
	/** 默认AI指令 */
	public int defaultAICommand;
	
	/** 默认AI模式 */
	public int defaultAIMode;
	
	/** 是否在待机状态下游荡 */
	public boolean isWanderOnIdle;
	
	/** 被动攻击半径 */
	public float passiveAttackRadius;
	
	/** 被动攻击半径平方 */
	public float passiveAttackRadiusT;
	
	/** 主动攻击半径 */
	public float initiativeAttackRadius;
	
	/** 主动攻击半径平方 */
	public float initiativeAttackRadiusT;
	
	/** 最大追击半径 */
	public float maxPursueRadius;
	
	/** 唤醒同伴半径 */
	public float wakeUpCompanionAttackRadius;
	
	/** 跟随攻击半径平方 */
	public float followAttackRadiusT;
	
	/** 跟随半径 */
	public float followRadius;
	
	/** 跟随半径平方 */
	public float followRadiusT;
	
	/** 可攻击目标类型 */
	public int[] attackInfluenceType;
	
	/** 地图移动类型 */
	public int mapMoveType;
	
	/** 走跑移速比率 */
	public int walkSpeedRatio;
	
	/** 是否启用仇恨目标切换 */
	public boolean needHateSwitchTarget;
	
	/** 是否使用驾驶方式移动 */
	public boolean needDrive;
	
	/** 驾驶方式转向半径 */
	public float driveTurnRadius;
	
	/** 驾驶方式加速度 */
	public int driveAccelerateSpeed;
	
	/** 可攻击目标类型 */
	public boolean[] attackInfluenceTypeT;
	
	/** 复活方式 */
	public int reviveType;
	
	/** 等级上限 */
	public int levelMax;
	
	/** 获取 */
	public static FightUnitConfig get(int id)
	{
		return _dic.get(id);
	}
	
	/** 设置字典 */
	public static void setDic(IntObjectMap<FightUnitConfig> dic)
	{
		_dic=dic;
	}
	
	/** 获取全部 */
	public static IntObjectMap<FightUnitConfig> getDic()
	{
		return _dic;
	}
	
	/** 读取字节流(简版) */
	@Override
	protected void toReadBytesSimple(BytesReadStream stream)
	{
		super.toReadBytesSimple(stream);
		
		this.id=stream.readInt();
		
		this.attackRange=stream.readInt();
		
		this.modelID=stream.readInt();
		
		this.vocation=stream.readInt();
		
		this.deathKeepTime=stream.readInt();
		
		this.reviveWaitTime=stream.readInt();
		
		this.reviveType=stream.readInt();
		
		this.isWanderOnIdle=stream.readBoolean();
		
		this.defaultAIMode=stream.readInt();
		
		this.defaultAICommand=stream.readInt();
		
		this.initiativeAttackRadius=stream.readFloat();
		
		this.passiveAttackRadius=stream.readFloat();
		
		this.maxPursueRadius=stream.readFloat();
		
		this.wakeUpCompanionAttackRadius=stream.readFloat();
		
		this.followRadius=stream.readFloat();
		
		int attackInfluenceTypeLen=stream.readLen();
		if(this.attackInfluenceType==null || this.attackInfluenceType.length!=attackInfluenceTypeLen)
		{
			this.attackInfluenceType=new int[attackInfluenceTypeLen];
		}
		int[] attackInfluenceTypeT=this.attackInfluenceType;
		for(int attackInfluenceTypeI=0;attackInfluenceTypeI<attackInfluenceTypeLen;++attackInfluenceTypeI)
		{
			int attackInfluenceTypeV;
			attackInfluenceTypeV=stream.readInt();
			
			attackInfluenceTypeT[attackInfluenceTypeI]=attackInfluenceTypeV;
		}
		
		this.mapMoveType=stream.readInt();
		
		this.walkSpeedRatio=stream.readInt();
		
		this.needDrive=stream.readBoolean();
		
		this.driveTurnRadius=stream.readFloat();
		
		this.driveAccelerateSpeed=stream.readInt();
		
		this.needHateSwitchTarget=stream.readBoolean();
		
	}
	
	@Override
	protected void afterReadConfig()
	{
		super.afterReadConfig();
		
		initiativeAttackRadiusT=initiativeAttackRadius*initiativeAttackRadius;
		passiveAttackRadiusT=passiveAttackRadius*passiveAttackRadius;
		followRadius=followRadiusT*followRadiusT;
		attackInfluenceTypeT=SkillInfluenceTypeConfig.getInfluenceSet(attackInfluenceType);
	}
	
	/** 读完所有表后处理 */
	public static void afterReadConfigAll()
	{
	
	}
	
	/** 写入字节流(简版) */
	@Override
	protected void toWriteBytesSimple(BytesWriteStream stream)
	{
		super.toWriteBytesSimple(stream);
		
		stream.writeInt(this.id);
		
		stream.writeInt(this.attackRange);
		
		stream.writeInt(this.modelID);
		
		stream.writeInt(this.vocation);
		
		stream.writeInt(this.deathKeepTime);
		
		stream.writeInt(this.reviveWaitTime);
		
		stream.writeInt(this.reviveType);
		
		stream.writeBoolean(this.isWanderOnIdle);
		
		stream.writeInt(this.defaultAIMode);
		
		stream.writeInt(this.defaultAICommand);
		
		stream.writeFloat(this.initiativeAttackRadius);
		
		stream.writeFloat(this.passiveAttackRadius);
		
		stream.writeFloat(this.maxPursueRadius);
		
		stream.writeFloat(this.wakeUpCompanionAttackRadius);
		
		stream.writeFloat(this.followRadius);
		
		if(this.attackInfluenceType!=null)
		{
			int[] attackInfluenceTypeT=this.attackInfluenceType;
			stream.writeLen(attackInfluenceTypeT.length);
			for(int attackInfluenceTypeVI=0,attackInfluenceTypeVLen=attackInfluenceTypeT.length;attackInfluenceTypeVI<attackInfluenceTypeVLen;++attackInfluenceTypeVI)
			{
				int attackInfluenceTypeV=attackInfluenceTypeT[attackInfluenceTypeVI];
				stream.writeInt(attackInfluenceTypeV);
				
			}
		}
		else
		{
			nullObjError("attackInfluenceType");
		}
		
		stream.writeInt(this.mapMoveType);
		
		stream.writeInt(this.walkSpeedRatio);
		
		stream.writeBoolean(this.needDrive);
		
		stream.writeFloat(this.driveTurnRadius);
		
		stream.writeInt(this.driveAccelerateSpeed);
		
		stream.writeBoolean(this.needHateSwitchTarget);
		
	}
	
}
