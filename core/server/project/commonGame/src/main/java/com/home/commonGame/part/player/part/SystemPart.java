package com.home.commonGame.part.player.part;
import com.home.commonBase.baseData.BaseClientPartData;
import com.home.commonBase.constlist.generate.InfoCodeType;
import com.home.commonBase.data.login.ClientLoginData;
import com.home.commonBase.data.login.PlayerSwitchGameData;
import com.home.commonBase.data.system.ClientOfflineWorkData;
import com.home.commonBase.data.system.InfoLogData;
import com.home.commonBase.data.system.PlayerToPlayerTCCWData;
import com.home.commonBase.data.system.PlayerWorkCompleteData;
import com.home.commonBase.data.system.PlayerWorkData;
import com.home.commonBase.global.BaseC;
import com.home.commonBase.global.CommonSetting;
import com.home.commonBase.global.Global;
import com.home.commonBase.part.player.clientData.SystemClientPartData;
import com.home.commonBase.part.player.data.SystemPartData;
import com.home.commonBase.table.table.PlayerTable;
import com.home.commonBase.tool.WorkReceiveTool;
import com.home.commonGame.constlist.system.PlayerLoginPhaseType;
import com.home.commonGame.constlist.system.PlayerLoginStateType;
import com.home.commonGame.control.LogicExecutor;
import com.home.commonGame.dataEx.PlayerLoginEachGameTempData;
import com.home.commonGame.global.GameC;
import com.home.commonGame.net.request.system.DailyRequest;
import com.home.commonGame.net.request.system.ReceiveClientOfflineWorkRequest;
import com.home.commonGame.part.player.Player;
import com.home.commonGame.part.player.base.PlayerBasePart;
import com.home.commonGame.server.GameReceiveSocket;
import com.home.commonGame.utils.GameUtils;
import com.home.shine.constlist.SLogType;
import com.home.shine.constlist.ThreadType;
import com.home.shine.control.DateControl;
import com.home.shine.control.LogControl;
import com.home.shine.control.ThreadControl;
import com.home.shine.ctrl.Ctrl;
import com.home.shine.data.BaseData;
import com.home.shine.dataEx.LogInfo;
import com.home.shine.global.ShineSetting;
import com.home.shine.net.base.BaseResponse;
import com.home.shine.support.collection.IntList;
import com.home.shine.support.collection.SList;
import com.home.shine.support.collection.SQueue;
import com.home.shine.support.concurrent.collection.NatureConcurrentQueue;
import com.home.shine.support.func.ObjectCall;
import com.home.shine.utils.MathUtils;
import com.home.shine.utils.ObjectUtils;
import com.home.shine.utils.TimeUtils;
import io.netty.util.internal.EmptyArrays;

/** 系统(generated by shine) */
public class SystemPart extends PlayerBasePart
{
	/** 数据 */
	private SystemPartData _d;
	
	/** 连接(不用volatile) */
	public GameReceiveSocket socket;
	
	/** 离线保留时间(ms)(主线程) */
	public long offlineKeepTime=0L;
	
	/** 退出状态等待(ms) */
	public long exitWaitTime=0;
	
	/** 登陆临时数据 */
	public PlayerLoginEachGameTempData loginEachTempData;
	
	/** 是否在客户端离线模式中 */
	private boolean _isClientOfflining=false;
	
	/** 是否初始化过 */
	private boolean _inited=false;
	
	/** 连接是否准备好(必须加volatile，不然顶号测试，会在InitClient后发上次登陆消息) */
	private volatile boolean _socketReady=false;
	
	/** 是否需要结束当前状态后退出 */
	private boolean _needExitNext=false;
	
	/** 退出信息码 */
	private int _nextExitCode=-1;
	
	/** 当前退出码 */
	private int _nowExitCode=-1;
	
	/** 登录状态(主线程写,所有线程读) */
	private volatile int _loginState=PlayerLoginStateType.Offline;
	
	public int loginPhase=PlayerLoginPhaseType.None;
	
	/** 登录过期时间 */
	public long loginingTime=0;
	
	/** 过程中离线事务组 */
	private SList<PlayerWorkData> _processOfflineWorkList=new SList<>(PlayerWorkData[]::new);
	
	/** 此次登录令牌(主线程) */
	private int _loginToken=-1;
	
	/** 退出回调 */
	private SList<Runnable> _exitOverCalls=new SList<>(Runnable[]::new);
	
	/** 当前执行器序号(-1为不在任何执行器中) */
	private volatile int _executorIndex=-1;
	
	/** 当前执行器 */
	private volatile LogicExecutor _executor;
	
	/** 是否切换执行器中 */
	private boolean _isSwitchingExecutor=false;
	
	/** 上次服务器运行序号 */
	private int _lastServerRunIndex=-1;
	
	/** 事务工具 */
	private WorkReceiveTool _workTool;
	
	/** 标准待办事务组(因为不能batch执行,所以用原生的)(切换场景时不执行) */
	private NatureConcurrentQueue _funcQueue=new NatureConcurrentQueue();
	
	/** 上次离线时间间隔(ms)(从上次离线到本次上线) */
	private long _lastOfflineDelay;
	
	/** 上次保持在线时间(ms)(从上次上线到本次离线) */
	private long _lastKeepOnlineDelay;
	
	/** 缓存的客户端离线事务 */
	private SList<ClientOfflineWorkData> _tempClientOfflineWorks;
	
	/** 流程日志 */
	private LogInfo _flowLog=new LogInfo();
	
	/** 是否为切换登录 */
	private boolean _isSwitchLogin=false;
	
	/** 临时计算变量 */
	protected IntList _tempClientRandomSeeds=new IntList();
	
	protected IntList _clientRandomSeeds=new IntList();
	
	@Override
	public void setData(BaseData data)
	{
		super.setData(data);
		
		_d=(SystemPartData)data;
	}
	
	/** 获取数据 */
	public SystemPartData getPartData()
	{
		return _d;
	}
	
	@Override
	protected BaseData createPartData()
	{
		return new SystemPartData();
	}
	
	@Override
	protected BaseClientPartData createClientData()
	{
		return new SystemClientPartData();
	}
	
	/** 写客户端数据(copyServer过后的) */
	@Override
	protected void writeClientData(BaseClientPartData data)
	{
		toWriteClientData((SystemClientPartData)data);
	}
	
	/** 写客户端数据具体执行(已执行过copyServer了,就是说CPO中与SPO同名同类型的属性无需再赋值) */
	private void toWriteClientData(SystemClientPartData data)
	{
		//毫秒时间
		data.serverTime=DateControl.getTimeMillis();
		data.serverBornCode=GameC.global.system.getServerBornCode();
		data.serverStartTime=GameC.global.system.getServerStartTime();
	}
	
	/** 构造函数(只在new后调用一次,再次从池中取出不会调用) */
	@Override
	public void construct()
	{
		_workTool=new WorkReceiveTool();
	}
	
	/** 初始化(创建后刚调用,与dispose成对) */
	@Override
	public void init()
	{
		_inited=true;
	}
	
	/** 析构(回池前调用,与init成对) */
	@Override
	public void dispose()
	{
		_inited=false;
		socket=null;
		_socketReady=false;
		_exitOverCalls.clear();
		_loginState=PlayerLoginStateType.Offline;
		offlineKeepTime=0L;
		
		_lastOfflineDelay=0;
		_lastKeepOnlineDelay=0;
		_isSwitchingExecutor=false;
		_flowLog.clear();
		_isSwitchLogin=false;
		
		_loginToken=-1;
		loginingTime=0;
	}
	
	/** 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程) */
	@Override
	public void afterReadData()
	{
		_workTool.setData(_d.workReceiverData);
		
		//兼容旧数据
		if(_d.logQueue==null)
			_d.logQueue=new SQueue<>(InfoLogData[]::new);

		//废弃字段，清空
		if (_d.clientRandomSeeds.length > 0)
		{
			_d.clientRandomSeeds=ObjectUtils.EmptyIntArr;
		}
	}
	
	/** 每秒调用 */
	@Override
	public void onSecond(int delay)
	{
		checkDaily();
	}
	
	/** 新创建时(该主对象在服务器上第一次被创建时的动作(一生只一次),(只对数据赋值就好,自定义数据构造的部分写到afterReadData里,因为这个完事儿就会回调到)) */
	@Override
	public void onNewCreate()
	{
		long time=me.getTimeMillis();
		
		_d.loginDate=time;
		_d.logoutDate=time;
		_d.nextDailyTime=DateControl.getNextDailyTime();
		
		if(CommonSetting.useOfflineGame)
		{
			_d.lastClientOfflineTime=me.getTimeMillis();
		}

        _d.clientRandomSeedIndex=0;
        _d.clientRandomSeeds=ObjectUtils.EmptyIntArr;
		
		_d.clientOfflineWorkTimeChangeNum=Global.clientOfflineWorkTimeChangeDailyNum;
	}
	
	/** 构造数据前 */
	@Override
	protected void beforeMakeData()
	{
		
	}
	
	@Override
	public void beforeEnterOnMain()
	{
		if(me.isCurrentGame())
		{
			//上次的服务器运行序号
			_lastServerRunIndex=_d.serverRunIndex;
			//标记新的
			_d.serverRunIndex=GameC.global.system.getRunIndex();
		}
	}
	
	/** 登录前(每次角色即将登录时调用) */
	@Override
	public void beforeLogin()
	{
        if (CommonSetting.needClientRandomSeeds)
        {
            makeClientRandomSeedKey();
            makeClientRandomSeeds();
        }
	}
	
	protected void makeClientRandomSeedKey()
	{
        if (_d.clientRandomSeedKey == 0 || CommonSetting.needClientRandomSeedsReset && _d.clientRandomSeedNeedReset)
        {
            _d.clientRandomSeedKey= MathUtils.randomRange(300,999);
            _d.clientRandomSeedNeedReset=false;
            _d.clientRandomSeedIndex=0;
        }
    }
	
	protected void makeClientRandomSeeds()
	{
		_tempClientRandomSeeds.clear();
		_clientRandomSeeds.clear();

		int len=Global.clientRandomSeedNum;

		for (int i = 0; i < len; ++i)
		{
            _tempClientRandomSeeds.add(i);
		}

        for (int i = len-1; i >=0; --i)
        {
            int index=(_d.clientRandomSeedKey^(len-6*i))&i;
            _clientRandomSeeds.add(_tempClientRandomSeeds.remove(index));
        }
	}
	
	/** 登出(每次角色登出或切出时调用) */
	@Override
	public void onLeave()
	{
		//setExecutor(null);
		//_isOnline=false;
		
		_needExitNext=false;
		_nextExitCode=-1;
		_nowExitCode=-1;
		
		_lastServerRunIndex=-1;
		_tempClientOfflineWorks=null;
	}
	
	/** 功能开启(id:功能ID) */
	@Override
	public void onFunctionOpen(int id)
	{
		
	}
	
	/** 功能关闭(id:功能ID) */
	@Override
	public void onFunctionClose(int id)
	{
		
	}
	
	@Override
	public void onDaily()
	{
		//赋值
		_d.clientOfflineWorkTimeChangeNum=Global.clientOfflineWorkTimeChangeDailyNum;
		
		_workTool.onDaily();
		
		SQueue<InfoLogData> queue;
		if(!(queue=_d.logQueue).isEmpty())
		{
			long removeTime=DateControl.getTimeMillis()-(Global.infoLogKeepTime*TimeUtils.dayTime);
			
			while(true)
			{
				InfoLogData head=queue.peek();
				
				if(head==null)
					break;
				
				if(head.logTime>removeTime)
					break;
				
				queue.poll();
			}
		}
	}
	
	/** 检查是否到了每天间隔 */
	public void checkDaily()
	{
		if(me.getTimeMillis()>=_d.nextDailyTime)
		{
			long nextDailyTimeT=DateControl.getNextDailyTime();
			
			if(_d.nextDailyTime!=nextDailyTimeT)
			{
				_d.nextDailyTime=nextDailyTimeT;
				
				//每天调用
				me.onDaily();
				
				//推客户端
				me.send(DailyRequest.create(nextDailyTimeT));
			}
		}
	}
	
	/** 是否初始化过 */
	public boolean inited()
	{
		return _inited;
	}
	
	/** 序列化时写表 */
	public void writePlayerTable(PlayerTable table)
	{
		table.createDate=_d.createDate;
		table.appVersion=_d.lastLoginAppVersion;
		table.sourceVersion=_d.lastLoginResourceVersion;
	}
	
	/** 记录鞥路信息(主线程)(第一阶段) */
	public void recordLoginInfo(ClientLoginData data)
	{
		//标记上次登录设备平台
		_d.lastLoginClientPlatformType=data.clientPlatformType;
		_d.lastLoginDeviceType=data.deviceType;
		_d.lastLoginDeviceUniqueIdentifier=data.deviceUniqueIdentifier;
		_d.lastLoginAppVersion=data.appVersion;
		_d.lastLoginResourceVersion=data.resourceVersion;
		
	}
	
	/** 记录上线时间(主线程)(第二阶段) */
	public void recordLoginDate()
	{
		//标记在线
		_d.onLineMark=true;
		_d.loginDate=me.getTimeMillis();
		_lastOfflineDelay=_d.loginDate-_d.logoutDate;
		_lastKeepOnlineDelay=0;
	}
	
	/** 记录下线时间(逻辑线程)(之后调用onLeave) */
	public void recordLogoutDate()
	{
		//标记离线
		_d.onLineMark=false;
		_d.logoutDate=me.getTimeMillis();
		_lastKeepOnlineDelay=_d.logoutDate-_d.loginDate;
		_lastOfflineDelay=0;
	}
	
	/** 添加退出完成回调(主线程回调) */
	public void addExitOverCall(Runnable func)
	{
		_exitOverCalls.add(func);
	}
	
	/** 获取退出完成回调,拷贝 */
	public SList<Runnable> getExitOverCalls()
	{
		SList<Runnable> list=_exitOverCalls;
		_exitOverCalls=new SList<>(Runnable[]::new);
		return list;
	}
	
	/** 设置执行器(切换过程中会置空) */
	public void setExecutor(LogicExecutor executor)
	{
		_executor=executor;
		_executorIndex=(executor!=null ? executor.getIndex() : -1);
	}
	
	/** 获取所在执行器(如没有则返回空) */
	public LogicExecutor getExecutor()
	{
		return _executor;
	}
	
	/** 是否在切换执行器中 */
	public boolean isSwitchingExecutor()
	{
		return _isSwitchingExecutor;
	}
	
	/** 是否切换执行器中 */
	public void setSwitchingExecutor(boolean value)
	{
		_isSwitchingExecutor=value;
	}
	
	/** 是否是当前执行器 */
	public boolean isCurrentExecutor(int index)
	{
		return _executorIndex==index;
	}
	
	/** 添加主线程执行(逻辑线程) */
	public void addMainFunc(Runnable func)
	{
		//离线不添加(其他状态都添加)
		if(isStateOffline())
		{
			if(ThreadControl.isMainThread())
			{
				func.run();
			}
			else
			{
				me.warnLog("离线状态调用了addMainFunc",Ctrl.getStackTrace());
			}
			
			return;
		}
		
		ThreadControl.addMainFunc(func);
	}
	
	/** 添加待办事务(主线程)(如是在主线程通过GetPlayer系列取出的Player然后addFunc,则一定会被执行) */
	public void addFunc(Runnable func)
	{
		//离线不添加(其他状态都添加)
		if(isStateOffline())
		{
			me.warnLog("离线状态调用了addFunc",Ctrl.getStackTrace());
			return;
		}
		
		_funcQueue.addFunc(func);
		
		notifyExecutor();
	}
	
	/** 添加自身待办事务(主线程) */
	public void addSelfFunc(ObjectCall<Player> func)
	{
		//离线不添加(其他状态都添加)
		if(isStateOffline())
		{
			me.warnLog("离线状态调用了addSelfFunc",Ctrl.getStackTrace());
			return;
		}
		
		_funcQueue.addFunc(()->
		{
			func.apply(me);
		});
		
		notifyExecutor();
	}
	
	private void notifyExecutor()
	{
		LogicExecutor executor;
		if((executor=_executor)!=null)
		{
			int index=executor.getIndex();
			
			executor.addFunc(()->
			{
				callFuncs(index);
			});
		}
	}
	
	/** 调用剩余方法(逻辑线程) */
	public void callFuncs(int nowEIndex)
	{
		Runnable run;
		
		NatureConcurrentQueue queue=_funcQueue;
		
		while(true)
		{
			//不是当前线程
			if(_executorIndex!=nowEIndex)
				return;
			
			run=queue.poll();
			
			if(run==null)
			{
				break;
			}
			
			run.run();
		}
	}
	
	/** 清空回调(主线程) */
	public void clearFuncs()
	{
		if(!_funcQueue.isEmpty())
		{
			me.warnLog("清空回调列表时,不为空");
			_funcQueue.clear();
		}
	}
	
	/** 将方法做完(逻辑线程)(退出时做) */
	public void callAllFuncs()
	{
		Runnable run;
		NatureConcurrentQueue queue=_funcQueue;
		
		while(true)
		{
			run=queue.poll();
			
			if(run==null)
			{
				break;
			}
			
			run.run();
		}
	}
	
	/** 登录状态(主线程写) */
	public void setLoginState(int value)
	{
		if(ShineSetting.openCheck)
		{
			ThreadControl.checkCurrentIsMainThread();
		}
		
		if(_loginState==value)
			return;
		
		_loginState=value;
		
		if(value!=PlayerLoginStateType.Logining && loginPhase!=PlayerLoginPhaseType.None)
		{
			loginPhase=PlayerLoginPhaseType.None;
		}
	}
	
	/** 登录状态 */
	public int getLoginState()
	{
		return _loginState;
	}
	
	/** 在线状态(主线程) */
	public boolean isStateOnline()
	{
		return _loginState==PlayerLoginStateType.Online;
	}
	
	/** 是否退出中(主线程) */
	public boolean isStateExiting()
	{
		return _loginState==PlayerLoginStateType.Exiting;
	}
	
	/** 是否离线(主线程) */
	public boolean isStateOffline()
	{
		return _loginState==PlayerLoginStateType.Offline;
	}
	
	/** 是否登录中(主线程) */
	public boolean isStateLogining()
	{
		return _loginState==PlayerLoginStateType.Logining;
	}
	
	/** 是否切换游戏服中(主线程) */
	public boolean isStateSwitching()
	{
		return _loginState==PlayerLoginStateType.Switching;
	}
	
	/** 在线或登录状态 */
	public boolean isStateOnlineOrLogining()
	{
		int temp;
		return (temp=_loginState)==PlayerLoginStateType.Online || temp==PlayerLoginStateType.Logining;
	}
	
	/** 登录令牌(主线程) */
	public void setLoginToken(int token)
	{
		_loginToken=token;
	}
	
	/** 登录令牌(主线程) */
	public int getLoginToken()
	{
		return _loginToken;
	}
	
	/** 是否与当前的服务器运行索引匹配(beforeLogin后可用) */
	public boolean isCurrentServerRunIndex()
	{
		return _lastServerRunIndex==_d.serverRunIndex;
	}
	
	/** 获取种子序号 */
	public int getSeedIndex()
	{
		return _d.clientRandomSeedIndex;
	}
	
	/** 设置种子序号 */
	public void setSeedIndex(int v)
	{
		_d.clientRandomSeedIndex=v;
	}
	
	private int getNextSeed()
	{
		int seed=_clientRandomSeeds.get(_d.clientRandomSeedIndex);
		
		if(++_d.clientRandomSeedIndex>=_clientRandomSeeds.size())
		{
			_d.clientRandomSeedIndex=0;
			_d.clientRandomSeedNeedReset=true;
		}
		return seed;
	}
	
	/** 获取下个客户端随机结果(ratio:千分位) */
	public boolean getClientRandom(int ratio)
	{
		return getNextSeed()/Global.clientRandomSeedNum*1000<ratio;
	}
	
	/** 客户端随机一个整形 */
	public int clientRandomInt(int range)
	{
		return getNextSeed()*range/Global.clientRandomSeedNum;
	}
	
	/** 客户端随机一个整形 */
	public boolean clientRandomProb(int prob,int max)
	{
		if(prob >= max)
		{
			return true;
		}
		
		if(prob<=0)
		{
			return false;
		}
		
		int seed=getNextSeed();
		
		return (float)seed/Global.clientRandomSeedNum<(float)prob / max;
	}
	
	/** 添加离线事务数据对过程中(主线程调用) */
	public void addProcessOfflineWork(PlayerWorkData data)
	{
		_processOfflineWorkList.add(data);
	}
	
	/** 释放掉缓存的过程切换离线事务(主线程执行) */
	public void flushProcessOfflineWork()
	{
		if(!_processOfflineWorkList.isEmpty())
		{
			flushOfflineWorkList(_processOfflineWorkList);
			_processOfflineWorkList.clear();
		}
	}
	
	/** 执行离线事务队列(主线程执行) */
	public void flushOfflineWorkList(SList<PlayerWorkData> list)
	{
		//空的跳过
		if(list.isEmpty())
			return;
		
		PlayerWorkData[] values=list.getValues();
		PlayerWorkData v;
		
		for(int i=0,len=list.size();i<len;++i)
		{
			v=values[i];
			
			me.system.executeWork(v);
		}
	}
	
	/** 是否接下来需要退出 */
	public boolean isNeedExitNext()
	{
		return _needExitNext;
	}
	
	/** 退出信息码 */
	public int getNextExitCode()
	{
		return _nextExitCode;
	}
	
	/** 设置是否接下来需要退出 */
	public void setNeedExitNext(boolean value,int code)
	{
		_needExitNext=value;
		_nextExitCode=code;
	}
	
	/** 当前退出码 */
	public void setNowExitCode(int code)
	{
		_nowExitCode=code;
	}
	
	public int getNowExitCode()
	{
		return _nowExitCode;
	}
	
	/** 退出时是否需要关闭连接 */
	public boolean getNeedCloseSocketAtExit()
	{
		return _nowExitCode!=InfoCodeType.PlayerExit_initiative;
	}
	
	/** 上次离线间隔(ms) */
	public long getLastOfflineDelay()
	{
		return _lastOfflineDelay;
	}
	
	/** 上次保持在线间隔(ms) */
	public long getLastKeepOnlineDelay()
	{
		return _lastKeepOnlineDelay;
	}
	
	/** 获取上次在线时间(如已在线，则返回当前时间) */
	public long getLastOnlineTime()
	{
		if(isStateOnlineOrLogining())
			return me.getTimeMillis();
		
		return _d.logoutDate;
	}
	
	/** 连接是否准备好 */
	public boolean getSocketReady()
	{
		return _socketReady;
	}
	
	public void setSocketReady(boolean value)
	{
		_socketReady=value;
	}
	
	/** 设置客户端离线事务组 */
	public void setTempClientOfflineWorks(SList<ClientOfflineWorkData> list)
	{
		_tempClientOfflineWorks=list;
	}
	
	/** 接收在线事务(主线程) */
	public void onAddWorkForMain(PlayerWorkData data)
	{
		addFunc(()->
		{
			executeWork(data);
		});
	}
	
	/** 事务完成(主线程) */
	public void onWorkCompleteForMain(PlayerWorkCompleteData data)
	{
		addFunc(()->
		{
			onWorkComplete(data);
		});
	}
	
	/** 事务完成组(池线程) */
	public void onWorkCompleteList(SList<PlayerWorkCompleteData> list)
	{
		PlayerWorkCompleteData[] values=list.getValues();
		PlayerWorkCompleteData v;
		
		for(int i=0,len=list.size();i<len;++i)
		{
			v=values[i];
			onWorkComplete(v);
		}
	}
	
	/** 事务完成(池线程) */
	public void onWorkComplete(PlayerWorkCompleteData data)
	{
		_workTool.onCompleteReceipt(data.workInstanceID,data.senderIndex);
	}
	
	/** 执行离线事务(逻辑线程,或离线的主线程) */
	public void executeWork(PlayerWorkData data)
	{
		executeWork(data,true);
	}
	
	/** 执行离线事务(逻辑线程,或离线的主线程) */
	public void executeWork(PlayerWorkData data,boolean needReceipt)
	{
		//有实例ID
		if(data.workInstanceID>0L && needReceipt)
		{
			int re=InfoCodeType.WorkError;
			
			if(_workTool.record(data))
			{
				if(data instanceof PlayerToPlayerTCCWData)
				{
					PlayerToPlayerTCCWData wData=(PlayerToPlayerTCCWData)data;
					re=GameC.playerWork.executePlayerTCC(me,wData);
				}
				else
				{
					GameC.playerWork.execute(me,data);
					re=0;
				}
			}
			
			receiptWork(data,re);
		}
		else
		{
			GameC.playerWork.execute(me,data);
		}
	}
	
	/** 事务回执 */
	private void receiptWork(PlayerWorkData data,int result)
	{
		ThreadControl.addMainFunc(()->
		{
			GameC.main.receiptPlayerWork(data,result);
		});
	}
	
	/** 是否客户端离线事务中 */
	public boolean isClientOfflining()
	{
		return _isClientOfflining;
	}
	
	/** 设置离线事务状态 */
	public void setIsClientOfflining(boolean value)
	{
		_isClientOfflining=value;
	}
	
	/** 执行客户端离线事务(主线程/逻辑线程 执行) */
	public void flushClientOfflineWorks()
	{
		if(!CommonSetting.useOfflineGame)
			return;

		if(_tempClientOfflineWorks==null || _tempClientOfflineWorks.isEmpty())
		{
			_tempClientOfflineWorks=null;
			return;
		}
		
		ClientOfflineWorkData data;
		
		for(int i=0;i<_tempClientOfflineWorks.size();i++)
		{
			data=_tempClientOfflineWorks.get(i);
			
			if(!toExecuteOneOfflineWork(data))
			{
				me.warnLog("客户端离线事务校验未过一个",data.getDataID(),data.toDataString());
			}
		}

		_tempClientOfflineWorks=null;
	}
	
	/** 添加客户端离线事务数据 */
	private boolean toExecuteOneOfflineWork(ClientOfflineWorkData data)
	{
		if(!CommonSetting.useOfflineGame)
		{
			return false;
		}
		
		//走过的
		if(data.workIndex<=_d.clientOfflineWorkReceiveIndex)
		{
			me.warnLog("执行客户端离线事务,已经执行过",data.workIndex,_d.clientOfflineWorkReceiveIndex);
			return true;
		}
		
		//标记修改
		_d.clientOfflineWorkReceiveIndex=data.workIndex;
		
		long delay=data.workTime-_d.lastClientOfflineTime;
		
		if(delay<0)
		{
			me.warnLog("执行客户端离线事务,时间非法",_d.lastClientOfflineTime,data.workTime);
			
			if(_d.clientOfflineWorkTimeChangeNum<=0)
			{
				me.warnLog("执行客户端离线事务时间非法,可用次数不足");
				return false;
			}
			
			_d.clientOfflineWorkTimeChangeNum--;
			_d.clientOfflineWorkTimeChangeTotalNum++;
			
			me.warnLog("执行客户端离线事务,时间非法,累计修改次数",_d.clientOfflineWorkTimeChangeTotalNum);
		}
		
		_isClientOfflining=true;
		
		//使用客户端的时间
		_d.lastClientOfflineTime=data.workTime;
		
		if(delay>0)
		{
			me.onOfflineTime(delay);
		}
		
		//执行失败
		if(!GameC.clientOffline.execute(me,data))
		{
			me.warnLog("执行客户端离线事务失败,事务dataID:",data.getDataID());
			_isClientOfflining=false;
			return false;
		}
		
		//当前序号
		_isClientOfflining=false;
		
		return true;
	}
	
	/** 执行客户端事务数据 */
	public void executeClientOfflineWork(ClientOfflineWorkData data)
	{
		boolean re=toExecuteOneOfflineWork(data);
		
		if(!re)
		{
			me.warnLog("客户端离线事务校验未过一个",data.getDataID(),data.toDataString());
		}
		
		me.send(ReceiveClientOfflineWorkRequest.create(_d.clientOfflineWorkReceiveIndex,re));
	}
	
	/** 获取客户端设备平台 */
	public int getClientPlatformType()
	{
		return _d.lastLoginClientPlatformType;
	}
	
	/** 客户端日志 */
	public void onClientLog(int type,String str)
	{
		LogControl.clientLog(SLogType.getClientMark(type)+me.getInfo()+' '+str);
		
		if(type==SLogType.Error)
		{
			LogControl.clientErrorLog(me.getInfo()+' '+str);
		}
	}
	
	/** 添加流程日志 */
	public void addFlowLog(int step)
	{
		if(step>_d.flowStep)
		{
			_d.flowStep=step;
			BaseC.logic.addFlowLog(_flowLog,me.role.uid,me.role.playerID,step);
		}
	}
	
	/** 记录日志数据 */
	public void recordInfoLog(InfoLogData data)
	{
		SQueue<InfoLogData> queue;
		
		(queue=_d.logQueue).offer(data);
		
		if(queue.size()>Global.infoLogKeepNum)
			queue.poll();
		
	}
	
	/** 设置是否切换登录 */
	public void setSwitchLogin(boolean value)
	{
		_isSwitchLogin=value;
	}
	
	public boolean isSwitchLogin()
	{
		return _isSwitchLogin;
	}
	
	@Override
	public void writeSwitchData(PlayerSwitchGameData data)
	{
		data.isSwitchLogin=_isSwitchLogin;
	}
	
	@Override
	public void readSwitchData(PlayerSwitchGameData data)
	{
		_isSwitchLogin=data.isSwitchLogin;
	}
	
}
