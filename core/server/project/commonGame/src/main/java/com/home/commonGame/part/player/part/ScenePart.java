package com.home.commonGame.part.player.part;
import com.home.commonBase.baseData.BaseClientPartData;
import com.home.commonBase.config.game.BattleConfig;
import com.home.commonBase.config.game.SceneConfig;
import com.home.commonBase.config.game.ScenePlaceElementConfig;
import com.home.commonBase.config.other.ScenePlaceConfig;
import com.home.commonBase.constlist.generate.BuffKeepType;
import com.home.commonBase.constlist.generate.RoleShowDataPartType;
import com.home.commonBase.constlist.generate.SceneInstanceType;
import com.home.commonBase.constlist.generate.TriggerEventType;
import com.home.commonBase.data.login.PlayerSwitchGameData;
import com.home.commonBase.data.scene.base.PosDirData;
import com.home.commonBase.data.scene.match.MatchSceneData;
import com.home.commonBase.data.scene.scene.SceneEnterArgData;
import com.home.commonBase.data.scene.scene.SceneLocationData;
import com.home.commonBase.data.scene.scene.SceneLocationRoleShowChangeData;
import com.home.commonBase.data.scene.scene.SceneServerEnterData;
import com.home.commonBase.data.scene.scene.SceneServerExitData;
import com.home.commonBase.data.social.roleGroup.PlayerRoleGroupMemberData;
import com.home.commonBase.global.BaseC;
import com.home.commonBase.global.CommonSetting;
import com.home.commonBase.global.Global;
import com.home.commonBase.part.player.clientData.SceneClientPartData;
import com.home.commonBase.part.player.data.ScenePartData;
import com.home.commonBase.scene.base.Role;
import com.home.commonBase.scene.base.Unit;
import com.home.commonGame.global.GameC;
import com.home.commonGame.logic.team.PlayerTeam;
import com.home.commonGame.logic.unit.CharacterUseLogic;
import com.home.commonGame.net.request.func.match.FuncMatchOverRequest;
import com.home.commonGame.net.request.scene.EnterNoneSceneRequest;
import com.home.commonGame.net.request.scene.RefreshCurrentLineRequest;
import com.home.commonGame.net.serverRequest.scene.login.PlayerLeaveSceneToSceneServerRequest;
import com.home.commonGame.part.player.base.PlayerBasePart;
import com.home.commonGame.scene.base.GameScene;
import com.home.commonGame.scene.unit.GameCharacterIdentityLogic;
import com.home.shine.ctrl.Ctrl;
import com.home.shine.data.BaseData;
import com.home.shine.dataEx.AffairTimeLock;
import com.home.shine.dataEx.AffairTimeOut;
import com.home.shine.support.collection.LongObjectMap;
import com.home.shine.utils.MathUtils;

/** 场景(generated by shine) */
public class ScenePart extends PlayerBasePart
{
	/** 数据 */
	private ScenePartData _d;
	
	/** 是否切换场景中 */
	private AffairTimeLock _switchingLock=new AffairTimeLock();
	
	/** 是否匹配的功能ID(-1就是没在匹配中) */
	private int _matchingFuncID=-1;
	
	/** 下个要进入的场景信息 */
	private SceneEnterArgData _nextEnterSceneData;
	
	/** 离开场景回调(serverScene用) */
	private Runnable _leaveSceneCall;
	
	private GameScene _preScene;
	
	/** 进入场景倒计时 */
	private AffairTimeOut _enterSceneTimeOut=new AffairTimeOut(this::enterSceneTimeOut,CommonSetting.enterSceneMaxWaitTime);
	
	/** 是否需要补发预备进入场景 */
	private boolean _needSupplyPreEnterScene;
	
	/** 当前所在场景位置 */
	private SceneLocationData _sceneLocation;
	
	/** 当前场景对象 */
	private GameScene _scene;
	
	/** 场景角色 */
	private Role _role;
	
	/** 角色单位 */
	private Unit _unit;
	
	/** 是否有下个场景 */
	private boolean _hasNextScene=false;
	
	/** 是否有断线重连进入 */
	private boolean _hasReconnectEnter=false;
	
	@Override
	public void setData(BaseData data)
	{
		super.setData(data);
		
		_d=(ScenePartData)data;
	}
	
	/** 获取数据 */
	public ScenePartData getPartData()
	{
		return _d;
	}
	
	@Override
	protected BaseData createPartData()
	{
		return new ScenePartData();
	}
	
	@Override
	protected BaseClientPartData createClientData()
	{
		return new SceneClientPartData();
	}
	
	/** 写客户端数据(copyServer过后的) */
	@Override
	protected void writeClientData(BaseClientPartData data)
	{
		toWriteClientData((SceneClientPartData)data);
	}
	
	/** 写客户端数据具体执行(已执行过copyServer了,就是说CPO中与SPO同名同类型的属性无需再赋值) */
	private void toWriteClientData(SceneClientPartData data)
	{
		
	}
	
	/** 构造函数(只在new后调用一次,再次从池中取出不会调用) */
	@Override
	public void construct()
	{
		
	}
	
	/** 初始化(创建后刚调用,与dispose成对) */
	@Override
	public void init()
	{
		
	}
	
	/** 析构(回池前调用,与init成对) */
	@Override
	public void dispose()
	{
	
	}
	
	/** 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程) */
	@Override
	public void afterReadData()
	{
		
	}
	
	/** 每秒调用 */
	@Override
	public void onSecond(int delay)
	{
		if(_preScene!=null)
		{
			_enterSceneTimeOut.onSecond();
		}
	}
	
	/** 新创建时(该主对象在服务器上第一次被创建时的动作(一生只一次),(只对数据赋值就好,自定义数据构造的部分写到afterReadData里,因为这个完事儿就会回调到)) */
	@Override
	public void onNewCreate()
	{
		_d.lastTownPosDir=new PosDirData();
		_d.lastTownPosDir.initDefault();
		
		if(CommonSetting.hasTown)
		{
			_d.lastTownID=Global.bornTownID;
			//出生点
			ScenePlaceConfig scenePlaceConfig=ScenePlaceConfig.get(_d.lastTownID);
			
			ScenePlaceElementConfig eConfig=scenePlaceConfig.getElement(Global.bornTownPosID);
			
			if(eConfig==null)
			{
				Ctrl.errorLog("未找到出生点:",Global.bornTownID,Global.bornTownPosID);
				return;
			}
			
			//出生位置
			_d.lastTownPosDir.setByFArr(eConfig.pos);
		}
		else
		{
			_d.lastTownID=-1;
		}
		
		_d.lineID=0;//默认0线
	}
	
	/** 构造数据前 */
	@Override
	protected void beforeMakeData()
	{
		
	}
	
	/** 登出(每次角色登出或切出时调用) */
	@Override
	public void onLeave()
	{
		if(_matchingFuncID>0)
		{
			//退出匹配
			GameC.scene.cancelMatch(me,_matchingFuncID);
			
			_matchingFuncID=-1;
		}
		
		//切换false
		setSwitching(false);
		clearPreEnterScene();
		
		_scene=null;
		_sceneLocation=null;
		_unit=null;
		_hasNextScene=false;
		
		_leaveSceneCall=null;
	}
	
	/** 功能开启(id:功能ID) */
	@Override
	public void onFunctionOpen(int id)
	{
		
	}
	
	/** 功能关闭(id:功能ID) */
	@Override
	public void onFunctionClose(int id)
	{
		
	}
	
	@Override
	public void beforeLoginOnMain()
	{
		//每次登录重新随机线号
		_d.lineID=MathUtils.randomInt(Global.sceneLineNum);
	}
	
	/** 获取场景 */
	public GameScene getScene()
	{
		if(CommonSetting.useSceneServer)
		{
			Ctrl.throwError("使用独立场景服，不允许访问getScene");
			return null;
		}
		
		return _scene;
	}
	
	/** 获取场景角色 */
	public Role getRole()
	{
		if(CommonSetting.useSceneServer)
		{
			Ctrl.throwError("使用独立场景服，不允许访问getRole");
			return null;
		}
		
		return _role;
	}
	
	/** 获取当前的主角(池线程) */
	public Unit getUnit()
	{
		if(CommonSetting.useSceneServer)
		{
			Ctrl.throwError("使用独立场景服，不允许访问getUnit");
			return null;
		}
		
		return _unit;
	}
	
	/** 当前是否切换中(逻辑线程) */
	public boolean isSwitching()
	{
		return _switchingLock.isLocking();
	}
	
	/** 设置切换状态(逻辑线程) */
	public void setSwitching(boolean bool)
	{
		if(bool)
		{
			_switchingLock.lockOn();
		}
		else
		{
			_switchingLock.unlock();
		}
	}
	
	/** 当前线ID */
	public int getLineID()
	{
		return _d.lineID;
	}
	
	/** 设置线ID */
	public void setLineID(int value)
	{
		if(_d.lineID==value)
			return;
		
		_d.lineID=value;
		
		me.send(RefreshCurrentLineRequest.create(value));
	}
	
	/** 设置当前场景进入参数数(可能是其他服务器地址) */
	public void setCurrentEnterArg(SceneEnterArgData data)
	{
		_d.currentSceneEnterArg=data;
		
		//进入到了对应的匹配场景
		if(_d.matchSceneData!=null && _d.matchSceneData.location.equalsThree(data.location))
		{
			_d.matchSceneData=null;
		}
	}
	
	/** 获取当前场景进入参数数据 */
	public SceneEnterArgData getCurrentEnterArg()
	{
		return _d.currentSceneEnterArg;
	}
	
	/** 是否使用缓存位置数据 */
	public boolean isUseCacheData()
	{
		return _d.currentSceneEnterArg.useCache;
	}
	
	/** 记录当前数据 */
	public void recordCurrentData()
	{
		if(_d.currentSceneEnterArg==null)
			return;
		
		if(_scene==null)
			return;
		
		SceneConfig config;
		
		//ID不匹配
		if((config=_scene.getConfig()).id!=_d.currentSceneEnterArg.location.sceneID)
		{
			Ctrl.warnLog("场景ID不该不匹配");
			return;
		}
		
		if(_unit!=null)
		{
			//保存位置
			PosDirData posDir=_unit.pos.getPosDir();
			
			if(_d.currentScenePosDir==null)
			{
				_d.currentScenePosDir=new PosDirData();
				_d.currentScenePosDir.initDefault();
			}
			
			_d.currentScenePosDir.copyPosDir(posDir);
			
			//是主城
			if(BaseC.constlist.sceneInstance_isTown(config.instanceType))
			{
				//保存主城信息
				_d.lastTownID=config.id;
				_d.lastTownPosDir.copyPosDir(posDir);
				//TODO:主城的cache数据，是否需要
			}
			
			me.character.saveCache(BuffKeepType.InCurrentScene);
		}
	}
	
	/** 清空当前场景保存信息 */
	public void clearCurrentSceneInfo()
	{
		_d.currentSceneEnterArg=null;
		_d.currentScenePosDir=null;
		
		me.character.clearCache();
	}
	
	/** 是否有当前场景信息 */
	public boolean hasCurrentSceneInfo()
	{
		return _d.currentSceneEnterArg!=null;
	}
	
	/** 当前是否匹配中 */
	public boolean isMatching()
	{
		return _matchingFuncID>0;
	}
	
	/** 获取当前的匹配功能ID */
	public int getMatchingFuncID()
	{
		return _matchingFuncID;
	}
	
	/** 设置匹配状态(同时会修改匹配中状态)(逻辑线程) */
	public void setMatchingFuncID(int funcID)
	{
		if(_matchingFuncID==funcID)
			return;
		
		_matchingFuncID=funcID;
	}
	
	/** 获取当前该去的线程索引(主线程) */
	public int getExecutorIndexByData()
	{
		//TODO:区分gameID
		//启用场景服
		if(CommonSetting.useSceneServer)
			return GameC.main.getLeastExecutor();
		
		//有当前在的场景,并且是当前服务器run
		if(me.system.isCurrentServerRunIndex() && _d.currentSceneEnterArg!=null)
		{
			if(SceneConfig.get(_d.currentSceneEnterArg.location.sceneID).isLoginEnter)
			{
				makeSceneEnterArgExecutorIndex(_d.currentSceneEnterArg);
				return _d.currentSceneEnterArg.location.executorIndex;
			}
		}
		
		if(_d.lastTownID>0)
		{
			SceneLocationData location=new SceneLocationData();
			location.sceneID=_d.lastTownID;
			
			GameC.scene.makeSingleSceneExecutorIndex(me,location);
			
			return location.executorIndex;
		}
		
		return GameC.main.getLeastExecutor();
		
		//找不到就随机线
		//return MathUtils.randomInt(ShineSetting.poolThreadNum);
	}
	
	/** 构造进入场景数据的执行器线号(主线程) */
	public void makeSceneEnterArgExecutorIndex(SceneEnterArgData data)
	{
		SceneLocationData location=data.location;
		
		if(location.instanceID!=-1)
		{
			if(location.executorIndex==-1)
			{
				me.throwError("执行器ID不该为空");
				return;
			}
		}
		else
		{
			if(location.lineID==-1)
				location.lineID=getLineID();
			
			GameC.scene.makeSingleSceneExecutorIndex(me,location);
		}
	}
	
	/** 重连后(socket处理) */
	public void onReconnect()
	{
		if(_scene!=null)
		{
			Unit unit=_scene.getCharacterByPlayerID(me.role.playerID);
			//连接重置
			((GameCharacterIdentityLogic)unit.identity).onSocketReplace();
		}
	}
	
	/** 进登录场景(逻辑线程) */
	public void enterLoginScene()
	{
		//还在引导中
		if(me.guide!=null && !me.guide.hasFinishFirstGuide())
		{
			enterNoneScene();
		}
		else
		{
			//有当前在的场景
			if(me.system.isCurrentServerRunIndex())
			{
				if(_d.matchSceneData!=null)
				{
					//直接赋值当前
					_d.currentSceneEnterArg=makeSceneEnterArgByLocation(_d.matchSceneData.location);
				}
				
				if(_d.currentSceneEnterArg!=null)
				{
					SceneConfig config=SceneConfig.get(_d.currentSceneEnterArg.location.sceneID);
					
					if(config.isLoginEnter)
					{
						boolean canEnterLastScene=true;
						
						//是绑定副本的
						if(config.battleID>0)
						{
							BattleConfig bConfig=BattleConfig.get(config.battleID);
							
							//超时了
							if(bConfig.maxKeepTime>0 && (me.system.getLastOfflineDelay()/1000)>bConfig.maxKeepTime)
							{
								canEnterLastScene=false;
							}
						}
						
						//还可进
						if(canEnterLastScene)
						{
							//用缓存数据进
							_d.currentSceneEnterArg.useCache=true;
							//进入目标场景
							me.getExecutor().playerEnterSignedScene(me,_d.currentSceneEnterArg);
							return;
						}
					}
				}
			}
			
			backToTown();
		}
	}
	
	/** 设置预备场景 */
	public void setPreScene(GameScene scene)
	{
		_preScene=scene;
		
		//计时
		_enterSceneTimeOut.start();
	}
	
	/** 清除预进入场景信息 */
	public void clearPreEnterScene()
	{
		_preScene=null;
		_enterSceneTimeOut.stop();
		_needSupplyPreEnterScene=false;
	}
	
	public boolean needSupplyPreEnterScene()
	{
		return _needSupplyPreEnterScene;
	}
	
	public void setNeedSupplyPreEnterScene(boolean value)
	{
		_needSupplyPreEnterScene=value;
	}
	
	/** 是否有预备场景 */
	public GameScene getPreScene()
	{
		return _preScene;
	}
	
	/** 检查是否立即进入场景 */
	public void checkPreEnter()
	{
		if(!me.system.socket.isConnectForLogic())
		{
			sceneReady();
		}
	}
	
	/** 绑定场景 */
	public void setScene(GameScene scene)
	{
		if(_scene!=null)
		{
			me.errorLog("绑定场景时，有旧值");
		}
		
		_scene=scene;
		_sceneLocation=scene.createLocationData();
		
		//自动分线场景
		if(scene.getConfig().instanceType==SceneInstanceType.AutoLinedScene)
		{
			long playerID=me.role.playerID;
			int sceneID=scene.getSceneID();
			int lineID=scene.getLineID();
			
			me.addMainFunc(()->
			{
				GameC.scene.addAutoLinedSceneOne(playerID,sceneID,lineID);
			});
		}
		
		//推送消息
		if(CommonSetting.needSyncRoleSocialSceneLocation)
		{
			SceneLocationRoleShowChangeData data=new SceneLocationRoleShowChangeData();
			data.type=RoleShowDataPartType.Location;
			data.localtion=scene.createLocationData();
			me.social.refreshRoleSocialData(data);
		}
	}
	
	/** 创建当前场景位置数据(可能为空) */
	public SceneLocationData createCurrentLocationData()
	{
		if(_scene!=null)
		{
			return _scene.createLocationData();
		}
		
		return null;
	}
	
	/** 绑定场景角色 */
	public void setRole(Role role)
	{
		_role=role;
	}
	
	/** 绑定单位 */
	public void setUnit(Unit unit)
	{
		_unit=unit;
	}
	
	/** 标记此次重连进入 */
	public void setReconnectEnter(boolean value)
	{
		_hasReconnectEnter=value;
	}
	
	/** 清空当前场景的索引 */
	public void clearNowScene(boolean hasNext)
	{
		//没有下一个了
		if(!hasNext)
		{
			clearCurrentSceneInfo();
			
			//清空
			//推送消息
			if(CommonSetting.needSyncRoleSocialSceneLocation)
			{
				SceneLocationRoleShowChangeData data=new SceneLocationRoleShowChangeData();
				data.type=RoleShowDataPartType.Location;
				me.social.refreshRoleSocialData(data);
			}
		}
		
		if(!CommonSetting.useSceneServer)
		{
			if(_scene!=null)
			{
				//自动分线场景
				if(_scene.getConfig().instanceType==SceneInstanceType.AutoLinedScene)
				{
					long playerID=me.role.playerID;
					int sceneID=_scene.getSceneID();
					int lineID=_scene.getLineID();
					
					me.addMainFunc(()->
					{
						GameC.scene.removeAutoLinedSceneOne(playerID,sceneID,lineID);
					});
				}
			}
			
			_scene=null;
			_sceneLocation=null;
			_role=null;
			_unit=null;
		}
		
		_hasNextScene=hasNext;
		_hasReconnectEnter=false;
	}
	
	/** 是否在场景中 */
	public boolean isInScene()
	{
		return _sceneLocation!=null;
	}
	
	/** 是否当前不在场景中,并且没有下个场景 */
	public boolean isNoneScene()
	{
		return _sceneLocation==null && !_hasNextScene;
	}
	
	/** 是否场景socket可就绪 */
	public boolean isSceneSocketReady()
	{
		//不在重连中,视为就绪
		return !_hasReconnectEnter;
	}
	
	/** 进入场景超时 */
	private void enterSceneTimeOut()
	{
		//直接ready
		sceneReady();
	}
	
	/** 客户端场景ready(非ServerScene用) */
	public void sceneReady()
	{
		//不在切换中
		if(_preScene==null)
		{
			me.warnLog("没有预备场景");
			
			if(isSwitching())
			{
				sceneMiss();
			}
			
			return;
		}
		
		//场景已被移除
		GameScene scene=me.getExecutor().getScene(_preScene.instanceID);
		
		if(scene==null)
		{
			clearPreEnterScene();
			sceneMiss();
			return;
		}
		
		scene=_preScene;
		
		//重连进入
		if(_hasReconnectEnter)
		{
			_hasReconnectEnter=false;
			
			clearPreEnterScene();
			setSwitching(false);
			
			//重连进入
			scene.gameInOut.playerEnterForReconnect(me);
		}
		else
		{
			clearPreEnterScene();
			setSwitching(false);
			
			scene.gameInOut.playerEnter(me);
		}
	}
	
	/** 场景丢失(回到主城)(此时在switching中)(逻辑线程) */
	public void sceneMiss()
	{
		me.warnLog("场景miss");
		
		clearNowScene(CommonSetting.hasTown);
		
		//关了切换标记
		setSwitching(false);
		
		backToTown();
	}
	
	/** 返回主城 */
	public void backToTown()
	{
		if(CommonSetting.hasTown)
		{
			toBackToTown();
		}
		else
		{
			if(_scene!=null)
			{
				_scene.gameInOut.playerLeave(me,CommonSetting.hasTown);
			}
			else
			{
				//此处需要清理一下,清除currentSceneInfo
				clearNowScene(false);
				
				enterNoneScene();
			}
		}
	}
	
	/** 执行回主城(已离开上个场景) */
	protected void toBackToTown()
	{
		if(!CommonSetting.hasTown)
			return;
		
		if(_d.lastTownID!=-1)
		{
			//赋值给当前
			_d.currentScenePosDir=_d.lastTownPosDir;
			//_d.currentSceneSaveData=null;//不读缓存
			//TODO:回头改成读取主城缓存
			
			SceneEnterArgData enterArgData=new SceneEnterArgData();
			enterArgData.location=new SceneLocationData();
			enterArgData.location.sceneID=_d.lastTownID;
			enterArgData.location.lineID=_d.lineID;
			enterArgData.useCache=true;
			
			me.getExecutor().playerEnterSignedScene(me,enterArgData);
			return;
		}
		
		Ctrl.throwError("找不到主城");
	}
	
	/** 进空场景 */
	private void enterNoneScene()
	{
		me.send(EnterNoneSceneRequest.create());
	}
	
	/** 离开当前场景并回主城(逻辑线程) */
	public void leaveNowScene()
	{
		doLeaveNowScene(CommonSetting.hasTown,null);
	}
	
	/** 执行离开当前场景(主线程/逻辑线程),回调在逻辑线程 */
	public void doLeaveNowScene(boolean hasNext,Runnable overCall)
	{
		if(CommonSetting.useSceneServer)
		{
			//切换中
			if(isSwitching())
			{
				_leaveSceneCall=overCall;
				SceneEnterArgData leaveSceneEnterArgData=GameC.scene.getLeaveSceneEnterArgData();
				setNextSceneLocation(leaveSceneEnterArgData);
				return;
			}
			else
			{
				doLeaveNowSceneAbs(overCall);
			}
		}
		else
		{
			if(_scene!=null)
			{
				_scene.gameInOut.playerLeave(me,hasNext);
			}
			
			if(overCall!=null)
				overCall.run();;
		}
	}
	
	/** 执行离开当前场景(主线程/逻辑线程),回调在逻辑线程 */
	public void doLeaveNowSceneAbs(Runnable overCall)
	{
		if(isInScene())
		{
			_leaveSceneCall=overCall;
			PlayerLeaveSceneToSceneServerRequest.create(me.role.playerID).send(_sceneLocation.serverID);
		}
		else
		{
			if(overCall!=null)
				overCall.run();
		}
	}
	
	/** 申请离开当前场景消息 */
	public void applyLeaveScene()
	{
		//当前没有场景
		if(_sceneLocation==null)
			return;
		
		if(checkCanLeaveNowScene())
		{
			if(CommonSetting.useSceneServer)
			{
				leaveNowScene();
			}
			else
			{
				if(_scene!=null)
				{
					if(_scene.gameInOut.checkCanLeave(me))
					{
						leaveNowScene();
					}
				}
			}
		}
	}
	
	/** 设置下个要进入的场景信息(只在当前服务器有效,不做跨服保留) */
	public void setNextSceneLocation(SceneEnterArgData data)
	{
		_nextEnterSceneData=data;
	}
	
	/** 获取下个要进入的数据 */
	public SceneEnterArgData getNextEnterSceneLocation()
	{
		return _nextEnterSceneData;
	}
	
	/** 申请进入场景(快捷方式)(等同客户端发起进入) */
	public void applyEnterScene(int sceneID)
	{
		applyEnterScene(sceneID,getLineID(),-1);
	}
	
	/** 申请进入场景(快捷方式)(等同客户端发起进入) */
	public void applyEnterScene(int sceneID,int lineID,int posID)
	{
		if(isSwitching())
		{
			me.warnLog("玩家正在场景切换中");
			return;
		}
		
		SceneConfig config=SceneConfig.get(sceneID);
		
		if(!BaseC.constlist.sceneInstance_canClientApplyEnter(config.instanceType))
		{
			me.warnLog("客户端不能主动的场景实例类型",config.id,config.instanceType);
			return;
		}
		
		//TODO:进入相同场景的限制
		//GameScene unit=player.unit.getScene();
		//
		//if(unit!=null && unit.getSceneID()==sceneID && unit.getLineID()==lineID)
		//{
		//	return;
		//}
		
		if(!me.role.checkRoleConditions(config.enterConditions,true))
		{
			me.warnLog("场景进入条件未达成");
			return;
		}
		
		if(lineID!=-1)
		{
			if((lineID<0 || lineID>=Global.sceneLineNum))
			{
				me.warnLog("场景线号非法");
				return;
			}
		}
		
		me.system.getExecutor().playerApplyEnterScene(me,sceneID,lineID,posID);
	}
	
	/** 检查是否可进入场景 */
	public boolean checkCanEnterScene(int sceneID)
	{
		if(isSwitching())
		{
			me.warnLog("玩家正在场景切换中");
			return false;
		}
		
		SceneConfig config=SceneConfig.get(sceneID);
		
		if(!me.role.checkRoleConditions(config.enterConditions,true))
		{
			me.warnLog("场景进入条件未达成");
			return false;
		}
		
		return true;
	}
	
	/** 进入指定场景，并检查 */
	public void playerEnterSignedSceneAndCheck(SceneLocationData data)
	{
		me.getExecutor().playerEnterSignedSceneAndCheck(me,makeSceneEnterArgByLocation(data),false);
	}
	
	/** 进入指定场景，不检查 */
	public void playerEnterSignedScene(SceneLocationData data)
	{
		me.getExecutor().playerEnterSignedScene(me,makeSceneEnterArgByLocation(data));
	}
	
	/** 构造场景进入参数数据 */
	public SceneEnterArgData makeSceneEnterArgByLocation(SceneLocationData data)
	{
		SceneEnterArgData re=BaseC.factory.createSceneEnterArgData();
		re.location=data;
		return re;
	}
	
	/** 构造场景进入参数数据 */
	public SceneEnterArgData makeSceneEnterArg(SceneLocationData data,int posID)
	{
		SceneEnterArgData re=BaseC.factory.createSceneEnterArgData();
		re.location=data;
		re.posID=posID;
		return re;
	}
	
	/** 获取自动分线场景的指定线(没有就返回-1) */
	public void makeAutoLinedSceneLocation(SceneLocationData data)
	{
		//有组队
		if(me.team!=null)
		{
			PlayerTeam team=me.team.getTeam();
			
			if(team!=null)
			{
				LongObjectMap<PlayerRoleGroupMemberData> memberDic=team.getMemberDic();
				
				SceneLocationData lData;
				
				PlayerRoleGroupMemberData[] values;
				PlayerRoleGroupMemberData v;
				
				for(int i=(values=memberDic.getValues()).length-1;i>=0;--i)
				{
					if((v=values[i])!=null)
					{
						if((lData=v.socialData.location)!=null)
						{
							//是该场景，并且不是自己
							if(lData.sceneID==data.sceneID && v.playerID!=me.role.playerID)
							{
								data.copy(lData);
								return;
							}
						}
					}
				}
			}
		}
	}
	
	/** triggerGM指令 */
	public void triggerGMCommand(int[] args)
	{
		GameScene scene=getScene();
		
		if(scene!=null)
		{
			Object[] objs=new Object[args.length];
			
			for(int i=0;i<args.length;i++)
			{
				objs[i]=args[i];
			}
			
			scene.trigger.triggerEvent(TriggerEventType.OnTriggerGMCommand,objs);
		}
	}
	
	@Override
	public void writeSwitchData(PlayerSwitchGameData data)
	{
		data.nextEnterSceneData=_nextEnterSceneData;
	}
	
	@Override
	public void readSwitchData(PlayerSwitchGameData data)
	{
		_nextEnterSceneData=data.nextEnterSceneData;
	}
	
	public void setSceneLocation(SceneLocationData data)
	{
		_sceneLocation=data;
	}
	
	/** 当前所在场景服id */
	public SceneLocationData getSceneLocation()
	{
		return _sceneLocation;
	}
	
	/** 创建场景服进入数据 */
	public SceneServerEnterData createEnterServerSceneData()
	{
		SceneServerEnterData data=BaseC.factory.createSceneServerEnterData();
		makeSceneServerEnterData(data);
		return data;
	}
	
	/** 构造场景服进入数据 */
	protected void makeSceneServerEnterData(SceneServerEnterData data)
	{
		//data.enterArg=_d.currentSceneEnterArg;
		
		CharacterUseLogic logic=me.character.getCurrentCharacterUseLogic();
		if(logic!=null)
			data.hero=logic.getCharacterUseData();
	}
	
	/** 匹配成功 */
	public void onMatchSuccess(MatchSceneData data)
	{
		//赋值
		_d.matchSceneData=data;
		//推送
		me.send(FuncMatchOverRequest.create(data.funcID));
		//匹配完成
		setMatchingFuncID(-1);
		//在线
		if(me.system.isStateOnline())
		{
			playerEnterSignedScene(data.location);
		}
	}
	
	/** 离开场景结束(逻辑线程) */
	public void onLeaveSceneOver(SceneServerExitData data)
	{
		//标记离开
		setSceneLocation(null);
		
		if(_leaveSceneCall!=null)
		{
			Runnable func=_leaveSceneCall;
			_leaveSceneCall=null;
			func.run();
		}
	}
	
	/** 检查是否可离开当前场景 */
	protected boolean checkCanLeaveNowScene()
	{
		if(_sceneLocation==null)
			return true;
		
		return true;
	}
	
}
