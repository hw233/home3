package com.home.shineTool.reflect.cls;

import com.home.shine.ctrl.Ctrl;
import com.home.shine.support.collection.IntObjectMap;
import com.home.shine.support.collection.SList;
import com.home.shine.support.collection.SMap;
import com.home.shine.support.func.ObjectFunc2;
import com.home.shine.utils.FileUtils;
import com.home.shine.utils.ObjectUtils;
import com.home.shine.utils.StringUtils;
import com.home.shineTool.constlist.CodeType;
import com.home.shineTool.constlist.VarType;
import com.home.shineTool.constlist.VisitType;
import com.home.shineTool.reflect.FieldInfo;
import com.home.shineTool.reflect.MainMethodInfo;
import com.home.shineTool.reflect.MethodArgInfo;
import com.home.shineTool.reflect.MethodInfo;
import com.home.shineTool.reflect.PropertyInfo;
import com.home.shineTool.reflect.code.CodeInfo;
import com.home.shineTool.reflect.code.CodeWriter;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/** 类信息 */
public abstract class ClassInfo
{
	/** 回车 */
	protected static final String regCheckEnter="[\\r\\n]";
	
	/** 结尾检查 */
	protected static final String endCheck="[\\{\\r\\n]";
	
	/** 回车 */
	public static final String Enter="\r\n";
	/** 换行 */
	public static final String Tab="\t";
	
	//private static final String oldDescribeMark="(generated by shine)";
	private static final String newDescribeMark="(generated by shine)";
	
	//seachTemp
	
	private static Pattern _importReg=Pattern.compile("import (.*?);");
	
	
	protected static char[] _clsNameEndStrs=new char[]{' ',',',':','\n','\r','{'};
	protected static char[] _superEndStrs=new char[]{',',':','\n','\r','{'};
	protected static char[] _implementsEndStrs=new char[]{':','\n','\r','{'};
	//
	
	protected Pattern _clsReg=Pattern.compile("public ((final|abstract|sealed| )*)class");
	
	/** 包信息(结尾不加点) */
	public String packageStr="";
	/** 类名(简名) */
	public String clsName="";
	/** 类描述 */
	public String clsDescribe="";
	/** 基础类名(简名) */
	public String extendsClsName="";
	/** 是否虚类 */
	public boolean isAbstract=false;
	/** 是否final */
	public boolean isFinal=false;
	
	/** 是否需要生成标记 */
	private boolean _needGenerateMark=true;
	
	/** 原生类文字 */
	protected String _clsStr="";
	
	/** 注解Key(java用) */
	protected SMap<String,String> _annotationDic=new SMap<>();
	/** 接口组 */
	protected Set<String> _implementsSet=new HashSet<>();
	/** 导入set */
	private Set<String> _importSet=new HashSet<>();
	/** 导入字典(name->qName) */
	private Map<String,String> _importDic=new HashMap<>();
	/** 值属性字典 */
	private Map<String,FieldInfo> _fieldDic=new HashMap<>();
	/** 值属性名字序列 */
	private List<String> _fieldNameList=new ArrayList<>();
	/** 构造函数方法(构造函数只能有一个) */
	protected MainMethodInfo _mainMethod;
	
	/** 方法字典 */
	private SMap<String,MethodInfo> _methodDic=new SMap<>();
	/** 方法key序列 */
	private List<String> _methodKeyList=new ArrayList<>();
	/** 方法名字字典 */
	private Map<String,MethodInfo> _methodDicByName=new HashMap<>();
	
	//子类复写属性
	/** 编码类型(子类赋值) */
	protected int _codeType;
	/** 属性正则 */
	protected Pattern _fieldReg;
	/** 方法正则 */
	protected Pattern _methodReg;
	
	
	//readTemp
	
	/** 类位置索引 */
	protected int _clsIndex=-1;
	/** cls内容序号开始 */
	private int _contentS=-1;
	/** cls内容序号结束 */
	private int _contentE=-1;
	/** 类内容 */
	protected String _content;
	/** 继承结束位置 */
	protected int _extendsEnd=-1;
	
	//writeTemp
	
	
	//path
	private String _path="";
	private String _rootPath="";
	
	public ClassInfo()
	{
		
	}
	
	//访问
	
	/** 代码类型 */
	public int getCodeType()
	{
		return _codeType;
	}
	
	/** 获取代码信息类 */
	public CodeInfo getCode()
	{
		return CodeInfo.getCode(_codeType);
	}
	
	/** 获取完全限定名 */
	public String getQName()
	{
		if(packageStr.isEmpty())
		{
			return clsName;
		}
		
		return packageStr + "." + clsName;
	}
	
	/** 获取继承类的完全限定名 */
	public String getExtendClsQName()
	{
		if(extendsClsName.isEmpty())
		{
			return "";
		}
		
		String pp=getImportPackage(extendsClsName);
		
		if(pp.isEmpty())
		{
			return packageStr + "." + extendsClsName;
		}
		else
		{
			return pp + "." + extendsClsName;
		}
	}
	
	/** 获取某属性在该类中的import记录,找不到返回本包(QName) */
	public String getImport(String type)
	{
		String re=_importDic.get(type);

		if(re==null)
		{
			if(packageStr.isEmpty())
			{
				return type;
			}
			else
			{
				return packageStr+"."+type;
			}
		}
		
		return re;
	}
	
	/** 获取导入Set */
	public Set<String> getImports()
	{
		return _importSet;
	}
	
	/** 获取某属性在该类中的import记录,找不到返回""(结尾不带点) */
	public String getImportPackage(String type)
	{
		String re=getImport(type);
		
		int index=re.lastIndexOf(".");
		
		if(index==-1)
		{
			return "";
		}
		
		return re.substring(0,index);
	}
	
	/** 获取值属性 */
	public FieldInfo getField(String name)
	{
		return _fieldDic.get(name);
	}
	
	/** 获取属性名组 */
	public List<String> getFieldNameList()
	{
		return _fieldNameList;
	}
	
	/** 获取构造函数 */
	public MainMethodInfo getMainMethod()
	{
		return _mainMethod;
	}
	
	/** 获取方法通过key */
	public MethodInfo getMethod(String key)
	{
		return _methodDic.get(key);
	}
	
	/** 获取方法通过名字 */
	public MethodInfo getMethodByName(String name)
	{
		return _methodDicByName.get(name);
	}
	
	//	/** 防区方法名组 */
	//	public List<String> getMethodNameList()
	//	{
	//		return _methodNameList;
	//	}
	
	/** 方法字典 */
	public SMap<String,MethodInfo> getMethodDic()
	{
		return _methodDic;
	}
	
	/** 清空 */
	public void clear()
	{
		packageStr="";
		clsDescribe="";
		clsName="";
		extendsClsName="";
		
		_clsStr="";
		
		_importSet.clear();
		_importDic.clear();
		_fieldDic.clear();
		_fieldNameList.clear();
		
		_methodDic.clear();
		_methodKeyList.clear();
		_methodDicByName.clear();
		_clsIndex=-1;
		_contentS=-1;
		_contentE=-1;
		_content="";
	}
	
	//直接操作
	
	/** 获取类文字 */
	public String getClsStr()
	{
		return _clsStr;
	}
	
	//元方法
	
	/** 添加注解 */
	public void addAnnotation(String str)
	{
		addAnnotation(str,"");
	}
	
	/** 添加注解 */
	public void addAnnotation(String str,String value)
	{
		_annotationDic.put(str,value);
	}
	
	/** 是否有某注解 */
	public boolean hasAnnotation(String str)
	{
		return _annotationDic.contains(str);
	}
	
	/** 获取注解参数 */
	public String getAnnotationValue(String key)
	{
		return _annotationDic.get(key);
	}
	
	/** 添加一个接口(完全限定名) */
	public void addImplements(String str)
	{
		//跟基类名完全一致(主要为C#)
		if(getExtendClsQName().equals(str))
		{
			return;
		}
		
		_implementsSet.add(str);
	}
	
	/** 添加导入(qName) */
	public void addImport(String qName)
	{
		if(qName==null || qName.isEmpty())
		{
			return;
		}
		
		if(_importSet.contains(qName))
		{
			return;
		}
		
		String n=StringUtils.getClassNameForQName(qName);
		
		//先删了旧的,因为不支持重名
		removeImportByClsName(n);
		
		_importSet.add(qName);
		_importDic.put(n,qName);
	}
	
	/** 删除导入 */
	public void removeImport(String qName)
	{
		if(qName==null || qName.isEmpty())
		{
			return;
		}
		
		if(!_importSet.contains(qName))
		{
			return;
		}
		
		_importSet.remove(qName);
		
		String n=StringUtils.getClassNameForQName(qName);
		
		_importDic.remove(n);
	}
	
	/** 通过类名删除导入 */
	public void removeImportByClsName(String name)
	{
		String qName=_importDic.get(name);
		
		if(qName==null)
		{
			return;
		}
		
		removeImport(qName);
	}
	
	/** 获取属性排序号 */
	public int getFieldIndex(String name)
	{
		return _fieldNameList.indexOf(name);
	}
	
	/** 添加值属性(如已存在就替换) */
	public void addField(FieldInfo field)
	{
		addField(field,_fieldNameList.size());
	}
	
	/** 添加Field到指定位置 */
	public void addField(FieldInfo field,int index)
	{
		if(_fieldDic.containsKey(field.name))
		{
			_fieldDic.put(field.name,field);
		}
		else
		{
			_fieldDic.put(field.name,field);
			
			if(index>_fieldNameList.size())
			{
				index=_fieldNameList.size();
			}
			
			_fieldNameList.add(index,field.name);
		}
	}
	
	/** 移除值属性 */
	public void removeField(String name)
	{
		if(_fieldDic.containsKey(name))
		{
			_fieldDic.remove(name);
			
			int index=_fieldNameList.indexOf(name);
			
			if(index!=-1)
			{
				_fieldNameList.remove(index);
			}
		}
	}
	
	/** 删了属性和对应导入 */
	public boolean removeFieldAndImport(String name)
	{
		FieldInfo field=getField(name);
		
		if(field==null)
		{
			return false;
		}
		
		//删导入
		removeImportByClsName(field.type);
		
		removeField(name);
		
		return true;
	}
	
	/** 移除所有属性 */
	public void removeAllField()
	{
		_fieldDic.clear();
		_fieldNameList.clear();
	}
	
	/** 添加构造函数 */
	public void addMainMethod(MainMethodInfo method)
	{
		_mainMethod=method;
	}
	
	/** 添加方法 */
	public void addMethod(MethodInfo method)
	{
		String key=method.getKey();
		
		if(_methodDic.contains(key))
		{
			_methodDic.put(key,method);
			_methodDicByName.put(method.name,method);
		}
		else
		{
			_methodDic.put(key,method);
			_methodDicByName.put(method.name,method);
			
			_methodKeyList.add(key);
		}
	}
	
	/** 添加方法(在afterName之后)(abs:是否一定重置位置) */
	public void addMethodAfterName(MethodInfo method,String afterName,boolean abs)
	{
		String key=method.getKey();
		
		if(!abs && _methodDic.contains(key))
		{
			_methodDic.put(key,method);
			_methodDicByName.put(method.name,method);
		}
		else
		{
			_methodDic.put(key,method);
			_methodDicByName.put(method.name,method);
			
			int oldIndex=_methodKeyList.indexOf(key);
			
			if(oldIndex!=-1)
			{
				_methodKeyList.remove(oldIndex);
			}
			
			MethodInfo targetMethod=_methodDicByName.get(afterName);
			
			String afteKey=targetMethod!=null ? targetMethod.getKey() : "";
			
			int index=afteKey.isEmpty() ? -1 : _methodKeyList.indexOf(afteKey);
			
			if(index==-1)
			{
				_methodKeyList.add(key);
			}
			else
			{
				_methodKeyList.add(index + 1,key);
			}
		}
	}
	
	/** 移除方法 */
	public void removeMethod(MethodInfo method)
	{
		String key=method.getKey();
		
		if(_methodDic.contains(key))
		{
			_methodDic.remove(key);
			
			_methodDicByName.remove(method.name);
			
			int index=_methodKeyList.indexOf(key);
			
			if(index!=-1)
			{
				_methodKeyList.remove(index);
			}
		}
	}
	
	/** 移除方法 */
	public void removeMethodByName(String name)
	{
		MethodInfo method=_methodDicByName.get(name);
		
		if(method!=null)
		{
			removeMethod(method);
		}
	}
	
	/** 读取注释 */
	protected String getDescribByStr(String str)
	{
		String re="";
		
		int desS=str.indexOf("/**");
		
		if(desS!=-1)
		{
			int desE=str.indexOf("*/");
			
			if(desE!=-1)
			{
				re=str.substring(desS + 3,desE);
				
				re=re.trim();
			}
		}
		
		return re;
	}
	
	protected void toMakeMethodVisit(MethodInfo prop,String[] arr)
	{
		for(String v:arr)
		{
			toMakeOneMethodVisit(prop,v);
		}
	}
	
	protected void toMakeOneMethodVisit(MethodInfo method,String str)
	{
		toMakePropOneVisit(method,str);
	}
	
	/** 设置visit类型 */
	protected void toMakePropVisit(PropertyInfo prop,String[] arr)
	{
		for(String v:arr)
		{
			toMakePropOneVisit(prop,v);
		}
	}
	
	/** 设置visit类型 */
	protected void toMakePropOneVisit(PropertyInfo prop,String str)
	{
		switch(str)
		{
			case "public":
			{
				prop.visitType=VisitType.Public;
			}
				break;
			case "private":
			{
				prop.visitType=VisitType.Private;
			}
				break;
			case "protected":
			{
				prop.visitType=VisitType.Protected;
			}
				break;
			case "static":
			{
				prop.isStatic=true;
			}
				break;
		}
	}
	
	/** 默认初始化 */
	protected abstract void initDefault();

	/** tab数 */
	protected abstract int getTabNum();
	
	
	//读取
	
	/** 从路径读取 */
	public void readFromPath(String path,boolean isSimple)
	{
		setPath(path);
		
		if(isSimple)
		{
			readByStringSimple(FileUtils.readFileForUTF(path));
		}
		else
		{
			readByString(FileUtils.readFileForUTF(path));
		}
		
	}
	
	/** 从字符串读取 */
	public void readByString(String str)
	{
		clear();
		
		_clsStr=str;
		
		try
		{
			
			readPackage();
			readPreHead();
			readHead();
			readHeadNext();
			
			readClassPart();
			readExtends();
			readImplements();
			
			readMainMethod();
			
			readEx();
			
			readMethods();
			readFields();
			
			readDescribes();
		}
		catch(Exception e)
		{
			Ctrl.throwError("类读取出错,path:"+_path,e);
		}
	}
	
	/** 从字符串简版读取(头,包,类名,继承等) */
	public void readByStringSimple(String str)
	{
		clear();
		
		_clsStr=str;
		
		readPackage();
		readPreHead();
		readHead();
		readHeadNext();
		
		readClassPart();
		readExtends();
		readImplements();
	}
	
	/** 读包内容 */
	private void readPackage()
	{
		toReadPackage();
	}
	
	protected abstract void toReadPackage();
	
	/** 读预备头(C# namespace) */
	protected void readPreHead()
	{
		
	}
	
	/** 读头 */
	protected void readHead()
	{
		Matcher m=_clsReg.matcher(_clsStr);
		
		if(m.find())
		{
			_clsIndex=m.start();
			
			String[] arr=m.group(1).split(" ");
			
			for(String s : arr)
			{
				switch(s)
				{
					case "final"://java
					case "sealed"://cs
					{
						isFinal=true;
					}
						break;
					case "abstract":
					{
						isAbstract=true;
					}
						break;
				}
			}
		}
		else
		{
			Ctrl.throwError("这个类有问题" + _content);
		}
		
		//_clsIndex=_clsStr.indexOf("public class ");
		//
		//if(_clsIndex==-1)
		//{
		//	_clsIndex=_clsStr.indexOf("public abstract class ");
		//
		//	if(_clsIndex==-1)
		//	{
		//		Ctrl.print("这个类有问题");
		//	}
		//	else
		//	{
		//		isAbstract=true;
		//	}
		//}
		//else
		//{
		//	isAbstract=false;
		//}
	}
	
	/** 读头下一步 */
	protected void readHeadNext()
	{
		readImports();
	}
	
	/** 读取导入 */
	protected void readImports()
	{
		String temp=_clsStr.substring(0,_clsIndex);
		
		Matcher m=_importReg.matcher(temp);
		
		while(m.find())
		{
			String zz=m.group(1);
			
			//以*结尾
			if(zz.charAt(zz.length()-1)=='*')
			{
				Ctrl.throwError("不支持使用import *",_path);
			}
			
			_importSet.add(zz);
			
			String[] arr2=zz.split("\\.");
			
			_importDic.put(arr2[arr2.length - 1],zz);
		}
	}
	
	/** 读类部分 */
	private void readClassPart()
	{
		clsDescribe=getDescribByStr(_clsStr.substring(0,_clsIndex));
		
		int end=_clsStr.indexOf("{",_clsIndex);
		
		int ee=StringUtils.getAnotherIndex(_clsStr,'{','}',end);
		
		_contentS=end + 1;
		_contentE=ee;
		
		_content=_clsStr.substring(_contentS,_contentE);
	}
	
	/** 读继承和接口 */
	protected void readExtends()
	{
		int end=_clsStr.indexOf("{",_clsIndex);
		
		int ccIndex=_clsStr.indexOf(" class ",_clsIndex);
		
		int nameS=ccIndex + 7;
		
		int nameE=StringUtils.indexOf(_clsStr,_clsNameEndStrs,nameS);
		
		clsName=_clsStr.substring(nameS,nameE);
		
		extendsClsName="";
		_extendsEnd=nameE;
		
		int superS=_clsStr.indexOf(getExtendsStr(),nameE);
		
		if(superS!=-1 && superS<=end)
		{
			superS+=getExtendsStr().length();
			
			int superE=StringUtils.indexOf(_clsStr,_superEndStrs,superS);
			
			if(superE!=-1 && superE<=end)
			{
				extendsClsName=_clsStr.substring(superS,superE).trim();
				
				_extendsEnd=superE;
			}
		}
	}
	
	/** 继承文字 */
	protected String getExtendsStr()
	{
		return "extends";
	}
	
	/** 写继承文字 */
	protected String writeExtendsStr()
	{
		return " extends ";
	}
	
	/** 读接口 */
	protected void readImplements()
	{
		int end=_clsStr.indexOf("{",_clsIndex);
		
		int imS=_clsStr.indexOf("implements ",_extendsEnd);
		
		if(imS!=-1 && imS<=end)
		{
			imS+="implements ".length();
			
			int imE=StringUtils.indexOf(_clsStr,_implementsEndStrs,imS);
			
			if(imE!=-1 && imE<=end)
			{
				String[] list=_clsStr.substring(imS,imE).split(",");
				
				for(String imA : list)
				{
					_implementsSet.add(imA.trim());
				}
			}
		}
	}
	
	/** 读取构造方法 */
	protected void readMainMethod()
	{
		Matcher m=getMainMethodReg().matcher(_content);
		
		boolean b=m.find();
		
		//没有
		if(b==false)
		{
			return;
		}
		
		String str=m.group();
		
		int index=m.start();
		
		MainMethodInfo method=new MainMethodInfo();
		method.startIndex=index;
		
		String[] ar=str.split(" ");
		
		toMakeMethodVisit(method,ar);
		
		toReadMainMethod(str,method);
		
		int left=_content.indexOf("{",index + str.length() + 1);
		int right=StringUtils.getAnotherIndex(_content,'{','}',left);
		
		method.endIndex=right;
		
		String content=_content.substring(left,right + 1);
		
		Pattern reg=Pattern.compile(getCode().Super + "\\((.*?)\\);" + Enter);
		
		Matcher m2=reg.matcher(content);
		
		if(m2.find())
		{
			//补括号和回车
			content="{"+Enter+content.substring(m2.end(),content.length());
			
			String ar2[]=m2.group(1).split(",");
			
			for(String s : ar2)
			{
				method.superArgs.add(s.trim());
			}
		}
		
		method.content=content;
		
		addMainMethod(method);
	}
	
	/** 构造函数正则 */
	protected abstract Pattern getMainMethodReg();
	
	/** 构造函数子类复写 */
	protected abstract void toReadMainMethod(String str,MethodInfo method);
	
	/** 额外写入 */
	protected abstract void readEx();
	
	/** 读方法组 */
	protected void readMethods()
	{
		Matcher m=_methodReg.matcher(_content);
		
		int lastStart=0;
		int lastEnd=0;
		
		while(m.find())
		{
			String str=m.group();
			
			//java 等号除外,因为java不允许赋默认值
			if(_codeType==CodeType.Java && str.contains("="))
			{
				continue;
			}
			
			int index=m.start();
			
			if(!toCheckMethodReadIndex(index))
			{
				continue;
			}
			
			//去掉结尾的\\r
			str=str.substring(0,str.length() - 1);
			
			MethodInfo method=new MethodInfo();
			
			method.startIndex=index;
			
			//判定组
			String[] ar=m.group(1).split(" ");
			
			toMakeMethodVisit(method,ar);
			
			toReadMethod(str,m,method);
			
			if(_mainMethod!=null)
			{
				//跟构造函数同名
				if(method.name.equals(_mainMethod.name))
				{
					continue;
				}
			}
			
			if(method.isAbstract)
			{
				method.endIndex=index + str.length()-1;//去掉结尾的结束符
				method.content="";
			}
			else
			{
				int left=_content.indexOf("{",index + str.length() - 1);//-1为了结尾为{的情况
				
				int right=StringUtils.getAnotherIndex(_content,'{','}',left);
				
				method.endIndex=right;
				
				method.content=_content.substring(left,right + 1);
			}
			
			//被上一个包含,舍弃
			if(lastStart<=method.startIndex && method.endIndex<=lastEnd)
			{
				continue;
			}
			
			lastStart=method.startIndex;
			lastEnd=method.endIndex;
			
			addMethod(method);
		}
		
		
	}
	
	/** 通用读方法参数 */
	protected void preReadMethodArgs(String str,MethodInfo method,ObjectFunc2<MethodArgInfo,String> func)
	{
		int left=str.indexOf("(");
		int right=str.indexOf(")");
		
		String ss=str.substring(left + 1,right);
		
		method.args.clear();
		
		if(ss.isEmpty())
		{
			return;
		}
		
		int zIndex=0;
		
		while(true)
		{
			zIndex=ss.indexOf("<",zIndex);
			
			if(zIndex==-1)
			{
				break;
			}
			
			int xIndex=StringUtils.getAnotherIndex(ss,'<','>',zIndex);
			
			String tt=ss.substring(zIndex,xIndex);
			//先换个别的
			tt=tt.replaceAll(",","&");
			
			//去掉全部空格
			tt=StringUtils.cutAllSpace(tt);
			
			//替换
			ss=ss.substring(0,zIndex) + tt + ss.substring(xIndex);
			
			zIndex=xIndex + 1;
		}
		
		String[] arr=ss.split(",");
		
		for(int i=0;i<arr.length;i++)
		{
			String tt=arr[i].trim();
			
			//再换回来
			tt=tt.replaceAll("\\&",",");
			
			method.args.add(func.apply(tt));
		}
	}
	
	/** 检查method的index是否可读 */
	protected boolean toCheckMethodReadIndex(int index)
	{
		return true;
	}
	
	protected abstract void toReadMethod(String str,Matcher matcher,MethodInfo method);
	
	/** 排序方法组 */
	protected void sortMethodsByStartIndex()
	{
		IntObjectMap<MethodInfo> dic=new IntObjectMap<>(_methodDic.size());
		
		List<Integer> list=new ArrayList<>();
		
		_methodDic.forEachValue(v->
		{
			dic.put(v.startIndex,v);
			list.add(v.startIndex);
		});
		
		Collections.sort(list);
		
		_methodKeyList.clear();
		
		for(int v : list)
		{
			_methodKeyList.add(dic.get(v).getKey());
		}
	}
	
	/** 获取方法key组 */
	public List<String> getMethodKeyList()
	{
		return _methodKeyList;
	}
	
	/** 读属性组 */
	private void readFields()
	{
		Matcher m=_fieldReg.matcher(_content);
		
		int current=0;
		
		while(m.find(current))
		{
			String str=m.group();
			current+=str.length()-1;//去掉尾部\n
			
			str=str.substring(getTabNum() + 1,str.length()-1);//去掉尾部\n
			
			int index=_content.indexOf(str);
			
			if(_mainMethod!=null)
			{
				//在其中
				if(index >= _mainMethod.startIndex && index<=_mainMethod.endIndex)
				{
					continue;
				}
			}
			
			for(MethodInfo method : _methodDic)
			{
				if(index >= method.startIndex && index<=method.endIndex)
				{
					continue;
				}
			}
			
			//没有初值
			if(str.indexOf("=")==-1)
			{
				//但是有括号
				if(str.indexOf("(")!=-1)
				{
					continue;
				}
			}
			
			FieldInfo field=new FieldInfo();
			field.startIndex=index;
			field.endIndex=index + str.length();
			
			String[] ar=str.split(" ");
			
			toMakePropVisit(field,ar);
			
			toReadField(str,field,m);
			
			addField(field);
		}
	}
	
	/** 格式化属性字符，去掉逗号后面的空格 */
	protected String formatFiledStr(String str)
	{
		int index=0;
		index=str.indexOf(',',index);
		
		while(index>0)
		{
			index++;
			
			if(index<str.length())
			{
				if(str.charAt(index)==' ')
				{
					str=str.substring(0,index)+str.substring(index+1,str.length());
				}
				
				index=str.indexOf(',',index);
			}
			else
			{
				break;
			}
			
			
		}
		
		return str;
	}
	
	protected abstract void toReadField(String str,FieldInfo field,Matcher m);
	
	/** 读取注释们 */
	private void readDescribes()
	{
		Map<Integer,PropertyInfo> dic=new HashMap<>();
		List<Integer> list=new ArrayList<>();
		
		for(PropertyInfo prop : _fieldDic.values())
		{
			dic.put(prop.startIndex,prop);
			list.add(prop.startIndex);
		}
		
		for(PropertyInfo prop : _methodDic)
		{
			dic.put(prop.startIndex,prop);
			list.add(prop.startIndex);
		}
		
		Collections.sort(list);
		
		int i;
		
		int lastIndex=0;
		
		for(i=0;i<list.size();i++)
		{
			PropertyInfo prop=dic.get(list.get(i));
			
			if(prop.startIndex<lastIndex)
			{
				Ctrl.print("AA");
			}
			
			String desStr=_content.substring(lastIndex,prop.startIndex);
			
			prop.describe=getDescribByStr(desStr);
			
			toReadPropAnnotation(desStr,prop);
			
			lastIndex=prop.endIndex;
		}
	}
	
	/** 读属性注解(java专用) */
	protected abstract void toReadPropAnnotation(String str,PropertyInfo prop);
	
	//写出
	
	/** 写到文件里 */
	public void writeToPath(String path)
	{
		FileUtils.writeFileForUTF(path,writeString());
	}
	
	/** 写回原文件 */
	public void write()
	{
		if(_path.isEmpty())
		{
			Ctrl.throwError("路径为空");
			return;
		}
		
		writeToPath(_path);
	}
	
	public void delete()
	{
		if(_path.isEmpty())
		{
			Ctrl.throwError("路径为空");
			return;
		}
		
		FileUtils.deleteFile(_path);
	}
	
	/** 写出字符串(同时赋值到_clsStr上) */
	public String writeString()
	{
		StringBuilder sb=new StringBuilder();
		writeToStringBuilder(sb);
		
		_clsStr=sb.toString();
		
		return _clsStr;
	}
	
	/** 写一些tab */
	protected void writeSomTab(StringBuilder sb,int num)
	{
		for(int i=0;i<num;i++)
		{
			sb.append(Tab);
		}
	}
	
	protected void writeClassTab(StringBuilder sb)
	{
		writeSomTab(sb,getTabNum() - 1);
	}
	
	protected void writeLeftTab(StringBuilder sb)
	{
		writeSomTab(sb,getTabNum());
	}
	
	/** 写方法tab */
	public void writeMethodTab(StringBuilder sb,int off)
	{
		writeSomTab(sb,getTabNum() + 1 + off);
	}
	
	/** 写到StringBuilder里 */
	private void writeToStringBuilder(StringBuilder sb)
	{
		beginWrite();
		
		writeFields(sb);
		writeMainMethod(sb);
		writeMethods(sb);
		
		writeEx(sb);
		
		writeClass(sb);
		writeHead(sb);
		writePackage(sb);
		
	}
	
	/** 开始写的清空 */
	protected void beginWrite()
	{
		//clsDescribe
		
		//if(clsDescribe.endsWith(oldDescribeMark))
		//		//{
		//		//	clsDescribe=clsDescribe.substring(0,clsDescribe.length()-oldDescribeMark.length());
		//		//}
		
		//补输出头
		if(_needGenerateMark && !clsDescribe.endsWith(newDescribeMark))
		{
			clsDescribe+=newDescribeMark;
		}
	}
	
	private void writeFields(StringBuilder sb)
	{
		for(int i=0;i<_fieldNameList.size();i++)
		{
			FieldInfo field=getField(_fieldNameList.get(i));
			
			writePropDescribe(sb,field);
			
			toWriteField(sb,field);
			
			writeLeftTab(sb);
			
			sb.append(Enter);
		}
	}
	
	/** 写一个属性的注释 */
	protected void writePropDescribe(StringBuilder sb,PropertyInfo prop)
	{
		if(prop.describe.isEmpty())
		{
			return;
		}
		
		writeLeftTab(sb);
		sb.append("/** ");
		sb.append(prop.describe);
		sb.append(" */");
		sb.append(Enter);
	}
	
	protected abstract void toWriteField(StringBuilder sb,FieldInfo field);
	
	private void writeMainMethod(StringBuilder sb)
	{
		if(_mainMethod!=null)
		{
			writePropDescribe(sb,_mainMethod);
		}
		
		toWriteMainMethod(sb);
	}
	
	protected abstract void toWriteMainMethod(StringBuilder sb);
	
	/** 写方法组 */
	private void writeMethods(StringBuilder sb)
	{
		for(int i=0;i<_methodKeyList.size();i++)
		{
			MethodInfo method=_methodDic.get(_methodKeyList.get(i));
			
			preWriteMethod(sb,method);
		}
	}
	
	protected void preWriteMethod(StringBuilder sb,MethodInfo method)
	{
		writePropDescribe(sb,method);
		
		toWriteMethod(sb,method);
	}
	
	protected abstract void toWriteMethod(StringBuilder sb,MethodInfo method);
	
	/** 额外写出 */
	protected abstract void writeEx(StringBuilder sb);
	
	/** 写类注释 */
	protected void writeClsDescribe(StringBuilder sb,String des)
	{
		if(!des.isEmpty())
		{
			writeClassTab(sb);
			sb.append("/** ");
			sb.append(clsDescribe);
			sb.append(" */");
			sb.append(Enter);
		}
	}
	
	/** 写类的访问修饰 */
	protected void writeClassVisitType(StringBuilder sb)
	{
		sb.append("public ");
	}
	
	/** 写出类 */
	protected void writeClass(StringBuilder sb)
	{
		StringBuilder sb2=new StringBuilder();
		
		writeClsDescribe(sb2,clsDescribe);
		
		afterWriteClassDescribe(sb2);
		
		writeClassTab(sb2);
		writeClassVisitType(sb2);
		
		//abstract
		if(isAbstract)
		{
			sb2.append("abstract ");
		}
		
		if(isFinal)
		{
			if(_codeType==CodeType.Java)
			{
				sb2.append("final ");
			}
			else if(_codeType==CodeType.CS)
			{
				sb2.append("sealed ");
			}
		}
		
		sb2.append("class ");
		sb2.append(clsName);
		
		if(!extendsClsName.isEmpty())
		{
			sb2.append(writeExtendsStr());
			sb2.append(extendsClsName);
		}
		
		writeImplements(sb2);
		
		sb2.append(Enter);
		writeClassTab(sb2);
		sb2.append("{");
		sb2.append(Enter);
		
		sb.insert(0,sb2.toString());
		
		writeClassTab(sb);
		sb.append("}");
		sb.append(Enter);
	}
	
	/** 写完类注释后 */
	protected void afterWriteClassDescribe(StringBuilder sb)
	{
		
	}
	
	protected void writeImplements(StringBuilder sb)
	{
		if(_implementsSet.size()>0)
		{
			sb.append(" implements ");
			
			List<String> list=ObjectUtils.getSortSetKeys(_implementsSet);
			
			int i=0;
			
			for(String s : list)
			{
				if(i>0)
				{
					sb.append(",");
				}
				
				sb.append(s);
				
				++i;
			}
		}
	}
	
	/** 写头 */
	protected void writeHead(StringBuilder sb)
	{
		writeImports(sb);
	}
	
	/** 写导入们 */
	protected void writeImports(StringBuilder sb)
	{
		StringBuilder sb2=new StringBuilder();
		
		for(String s : ObjectUtils.getSortSetKeys(_importSet))
		{
			writeClassTab(sb2);
			sb2.append("import ");
			sb2.append(s);
			sb2.append(";");
			sb2.append(Enter);
		}
		
		sb2.append(Enter);
		
		sb.insert(0,sb2.toString());
	}
	
	/** 写出包 */
	private void writePackage(StringBuilder sb)
	{
		toWritePackage(sb);
	}
	
	/** 写出包 */
	protected abstract void toWritePackage(StringBuilder sb);
	
	
	/** 获取该类的路径(如果是自己new出来的,则没有) */
	public String getPath()
	{
		return _path;
	}
	
	/** 根路径 */
	public String getRootPath()
	{
		return _rootPath;
	}
	
	/** 设置路径 */
	public void setPath(String path)
	{
		_path=path;
		_rootPath=FileUtils.getCodeRoot(path);
	}
	
	/** 设置跟路径 */
	public void setRootPath(String path)
	{
		_rootPath=path;
	}
	
	/** 获取某完全限定名对应的类路径(以此_rootPath为基础) */
	public String getQNamePath(String qName)
	{
		if(_rootPath.isEmpty())
		{
			Ctrl.throwError("root路径为空");
			return "";
		}
		
		qName=qName.replace('.','/');
		
		return _rootPath + "/" + qName + "." + CodeType.getExName(_codeType);
	}
	
	//get
	
	/** 根据类型获取类信息 */
	public static ClassInfo getClassInfo(int codeType)
	{
		switch(codeType)
		{
			case CodeType.Java:
			{
				return new JavaClassInfo();
			}
			case CodeType.AS3:
			{
				return new AS3ClassInfo();
			}
			case CodeType.CS:
			{
				return new CSClassInfo();
			}
			case CodeType.TS:
			{
				return new TSClassInfo();
			}
		}
		
		return null;
	}
	
	/** 根据扩展名获取类信息 */
	private static ClassInfo getClassInfoByExName(String exName)
	{
		int type=CodeType.getTypeByExName(exName);
		
		return getClassInfo(type);
	}
	
	/** 读文件 */
	private static ClassInfo readFile(File f)
	{
		String exName=FileUtils.getFileExName(f.getName());
		
		ClassInfo cls=getClassInfoByExName(exName);
		
		cls.readFromPath(f.getPath(),false);
		
		return cls;
	}
	
	/** 读文件(头,包,类名,继承等) */
	private static ClassInfo readFileSimple(File f)
	{
		String exName=FileUtils.getFileExName(f.getName());
		
		ClassInfo cls=getClassInfoByExName(exName);
		
		cls.readFromPath(f.getPath(),true);
		
		return cls;
	}
	
	/** 获取某路径的空类 */
	public static ClassInfo getVoidClassInfoFromPath(String path)
	{
		String pp=FileUtils.getPathPackage(path);
		
		String exName=FileUtils.getFileExName(path);
		
		ClassInfo cls=getClassInfoByExName(exName);
		
		cls.setPath(path);
		
		cls.packageStr=pp;
		cls.clsName=FileUtils.getFileFrontName(new File(path).getName());
		
		cls.initDefault();
		
		return cls;
	}
	
	/** 获取指定路径的类 */
	public static ClassInfo getClassInfoFromPath(String path)
	{
		File f=new File(path);
		
		if(f.exists())
		{
			return readFile(f);
		}
		
		return null;
	}
	
	/** 获取指定路径的类(没有就创建个空的) */
	public static ClassInfo getClassInfoFromPathAbs(String path)
	{
		File f=new File(path);
		
		if(f.exists())
		{
			return readFile(f);
		}
		
		return getVoidClassInfoFromPath(path);
	}
	
	/** 获取指定路径的简版类(没有就创建个空的)(头,包,类名,继承等) */
	public static ClassInfo getSimpleClassInfoFromPath(String path)
	{
		File f=new File(path);
		
		if(f.exists())
		{
			return readFileSimple(f);
		}
		
		return null;
	}
	
	/** 获取指定路径的简版类(没有就创建个空的)(头,包,类名,继承等) */
	public static ClassInfo getSimpleClassInfoFromPathAbs(String path)
	{
		File f=new File(path);
		
		if(f.exists())
		{
			return readFileSimple(f);
		}
		
		return getVoidClassInfoFromPath(path);
	}
	
	//special
	
	/** 加入shine的东西 */
	public void addShineThings()
	{
		
	}
	
	/** 创建方法写入 */
	public CodeWriter createWriter()
	{
		return CodeWriter.createByCls(this);
	}
	
	/** 获取变量内含类型(QName) */
	public void getVarInnerType(SList<String> list,String type)
	{
		int varType=getCode().getVarType(type);
		
		if(varType==VarType.CustomObject)
		{
			list.add(getImport(type));
		}
		else if(VarType.isBaseType(varType))
		{
		
		}
		else if(varType==VarType.Array)
		{
			getVarInnerType(list,CodeInfo.getVarArrayType(type));
		}
		else if(varType==VarType.List || varType==VarType.Set || varType==VarType.Queue)
		{
			getVarInnerType(list,CodeInfo.getVarCollectionOneType(type));
		}
		else if(varType==VarType.Map)
		{
			CodeInfo.CollectionTwoType twoType=CodeInfo.getVarCollectionTwoType(type);
			
			getVarInnerType(list,twoType.type0);
			getVarInnerType(list,twoType.type1);
		}
	}
	
	public void setNeedGenerateMark(boolean value)
	{
		_needGenerateMark=value;
	}
	
	public String getFieldWrap(String str)
	{
		return getCode().getFieldWrap(str);
	}
	
	public String getThisFront()
	{
		return getCode().getThisFront();
	}
	
	/** 给属性尝试添加this */
	public String addThis(String str)
	{
		if(str.startsWith("this."))
			return str;
		
		return "this."+str;
	}
}
