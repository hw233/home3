package com.home.commonClient.part.player.part;
import com.home.commonBase.config.game.InfoCodeConfig;
import com.home.commonBase.constlist.generate.ClientPlatformType;
import com.home.commonBase.constlist.generate.InfoCodeType;
import com.home.commonBase.constlist.generate.PlatformType;
import com.home.commonBase.constlist.generate.RobotFlowStepType;
import com.home.commonBase.constlist.generate.SexType;
import com.home.commonBase.constlist.generate.VocationType;
import com.home.commonBase.constlist.system.GameAreaDivideType;
import com.home.commonBase.control.CodeCheckRecord;
import com.home.commonBase.data.login.ClientLoginData;
import com.home.commonBase.data.login.ClientLoginResultData;
import com.home.commonBase.data.login.ClientLoginServerInfoData;
import com.home.commonBase.data.login.CreatePlayerData;
import com.home.commonBase.data.login.PlayerLoginData;
import com.home.commonBase.global.BaseC;
import com.home.commonBase.global.CommonSetting;
import com.home.commonBase.part.player.clientData.SystemClientPartData;
import com.home.commonClient.constlist.system.LoginFlowType;
import com.home.commonClient.control.LogicExecutor;
import com.home.commonClient.global.ClientC;
import com.home.commonClient.global.ClientGlobal;
import com.home.commonClient.net.base.GameResponse;
import com.home.commonClient.net.httpRequest.ClientLoginHttpRequest;
import com.home.commonClient.net.httpRequest.ClientLoginSelectHttpRequest;
import com.home.commonClient.net.request.login.CreatePlayerRequest;
import com.home.commonClient.net.request.login.LoginGameRequest;
import com.home.commonClient.net.request.login.PlayerLoginRequest;
import com.home.commonClient.net.request.login.PlayerSwitchGameRequest;
import com.home.commonClient.net.request.system.SaveBooleanRequest;
import com.home.commonClient.net.request.system.SaveIntRequest;
import com.home.commonClient.net.request.system.SaveStringRequest;
import com.home.commonClient.net.response.login.InitClientResponse;
import com.home.commonClient.part.player.base.PlayerBasePart;
import com.home.commonClient.server.ClientServer;
import com.home.shine.control.DateControl;
import com.home.shine.ctrl.Ctrl;
import com.home.shine.data.BaseData;
import com.home.shine.dataEx.AffairTimeOut;
import com.home.shine.net.socket.BaseSocket;
import com.home.shine.support.collection.SList;
import com.home.shine.timer.TimeDriver;
import com.home.shine.utils.MathUtils;

/** 系统(generated by shine) */
public class SystemPart extends PlayerBasePart
{
	/** 数据 */
	private SystemClientPartData _d;
	
	/** 创建名字后缀 */
	public int nameIndex=0;
	
	/** 执行器序号 */
	public int executorIndex=-1;
	
	/** 是否初始化好 */
	private boolean _inited=false;
	
	/** game服信息 */
	private ClientLoginServerInfoData _gameInfo;
	
	/** 登录服链接 */
	private String _loginURL;
	
	/** 是否是切换中(否则就是登陆中) */
	private boolean _isSwitching=false;
	
	private ClientServer _server;
	
	private TimeDriver _timeDriver=new TimeDriver();
	
	/** 流程步(不存库的) */
	private int _flowStep=-1;
	
	/** 登录流程 */
	private int _loginFlow=-1;
	
	/** 登录流程超时 */
	private AffairTimeOut _loginTimeOut=new AffairTimeOut(this::loginFlowTimeOut);
	
	/** 客户端随机种子序号 */
	private int _clientRandomIndex;
	
	/** 是否进入过初次场景 */
	private boolean _enteredFirstScene=false;
	
	/** 是否退出游戏了 */
	public boolean isLeftGame=false;
	
	private AffairTimeOut _testLoginTimeOut=new AffairTimeOut(this::testLoginTimeOut,20);
	
	private SList<GameResponse> _responseList=new SList<>(GameResponse[]::new);
	
	@Override
	public void setData(BaseData data)
	{
		super.setData(data);
		
		_d=(SystemClientPartData)data;
	}
	
	/** 获取数据 */
	public SystemClientPartData getPartData()
	{
		return _d;
	}
	
	/** 构造函数(只在new后调用一次,再次从池中取出不会调用) */
	@Override
	public void construct()
	{
		
	}
	
	/** 构造数据前 */
	@Override
	protected void beforeMakeData()
	{
		
	}
	
	/** 初始化(创建后刚调用,与dispose成对) */
	@Override
	public void init()
	{
		
	}
	
	/** 析构(回池前调用,与init成对) */
	@Override
	public void dispose()
	{
		_inited=false;
		_isSwitching=false;
		_enteredFirstScene=false;
		
		//if(_server!=null)
		//{
		//	_server.dispose();
		//	_server=null;
		//}
		
		_responseList.clear();
	}
	
	/** 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程) */
	@Override
	public void afterReadData()
	{
		_clientRandomIndex=0;
		
		//查看下每个机器人都设置是否有影响
		DateControl.setCurrentTime(_d.serverTime);
	}
	
	/** 每秒调用 */
	@Override
	public void onSecond(int delay)
	{
		_loginTimeOut.onSecond();
		
		_testLoginTimeOut.onSecond();
	}
	
	/** 功能开启(id:功能ID) */
	@Override
	public void onFunctionOpen(int id)
	{
		
	}
	
	/** 功能关闭(id:功能ID) */
	@Override
	public void onFunctionClose(int id)
	{
		
	}
	
	@Override
	public void onLeave()
	{
		_isSwitching=false;
		_enteredFirstScene=false;
		
		if(_server!=null)
		{
			_server.dispose();
			_server=null;
		}
	}
	
	/** 每帧调用 */
	public void onFrame(int delay)
	{
		_timeDriver.tick(delay);
	}
	
	/** 获取连接 */
	public BaseSocket getSocket()
	{
		if(_server!=null)
			return _server.getSocket();
		
		return null;
	}
	
	/** 获取自己的timeDriver */
	public TimeDriver getTimeDriver()
	{
		return _timeDriver;
	}
	
	/** 获取所在执行器(如没有则返回空) */
	public LogicExecutor getExecutor()
	{
		if(executorIndex==-1)
		{
			return null;
		}
		
		return ClientC.main.getExecutor(executorIndex);
	}
	
	/** 记录步骤 */
	public void recordStep(int step)
	{
		if(_flowStep>=step)
			return;
		
		_flowStep=step;
		
		ClientC.main.recordStep(me,step);
	}
	
	/** 开始登录 */
	public void startLogin()
	{
		//重置标记
		isLeftGame=false;
		
		me.log("startLogin");
		
		SList<String> list=ClientGlobal.getLoginURLList();
		
		_loginURL=list.get(MathUtils.randomInt(list.size()));
		
		startLoginFlow(LoginFlowType.LoginHttp);
		
		sendHttpLogin();
	}
	
	protected void sendHttpLogin()
	{
		ClientLoginHttpRequest.create(CodeCheckRecord.msgDataVersion,BaseC.config.getMsgDataVersion(),createClientLoginData()).sendByPlayer(me);
	}
	
	/** 创建登录数据 */
	protected ClientLoginData createClientLoginData()
	{
		ClientLoginData data=new ClientLoginData();
		data.uid=me.role.uid;
		data.countryID=ClientGlobal.countryID;
		data.platform=PlatformType.Visitor;
		data.deviceType="ios";
		data.deviceUniqueIdentifier="1234567890";
		data.clientPlatformType=ClientPlatformType.Windows;
		
		return data;
	}
	
	/** 登录http失败 */
	public void onLoginHttpFailed()
	{
		me.recordStep(RobotFlowStepType.ClientLoginFailed);
		
		cancelLoginFlow();
		
		me.exitPassive();
	}
	
	/** 登录http成功 */
	public void onLoginHttpSuccess(ClientLoginResultData data)
	{
		//int loginLogin,ClientLoginServerInfoData gameInfo
		//分服的
		if(CommonSetting.areaDivideType==GameAreaDivideType.Split)
		{
			//更新地址
			_loginURL="http://" + data.loginInfo.host + ":" + data.loginInfo.port;
			
			ClientLoginSelectHttpRequest msg=ClientLoginSelectHttpRequest.create(data.loginInfo.token,ClientGlobal.areaID);
			msg.me=me;
			msg.sendByPlayer(me);
		}
		else
		{
			loginGame(data.gameInfo);
		}
	}
	
	/** 登录逻辑服 */
	public void loginGame(ClientLoginServerInfoData gameInfo)
	{
		startLoginFlow(LoginFlowType.ConnectGame);
		
		me.recordStep(RobotFlowStepType.LoginGame);
		
		_gameInfo=gameInfo;

		_server=me.createClientServer();
		_server.init();
		
		me.log("connectGame",gameInfo.host,gameInfo.port);
		//连接
		_server.connectGame(gameInfo.host,gameInfo.port);
	}
	
	/** 连接逻辑服成功(逻辑线程) */
	public void connectGameSuccess()
	{
		me.log("connectGameSuccess");
		
		startLoginFlow(LoginFlowType.LoginGame);
		
		//切换game
		if(_isSwitching)
		{
			_isSwitching=false;
			me.send(PlayerSwitchGameRequest.create(_gameInfo.token));
		}
		//登录game
		else
		{
			me.recordStep(RobotFlowStepType.ConnectGameSuccess);
			
			me.send(LoginGameRequest.create(_gameInfo.token,CodeCheckRecord.msgDataVersion,BaseC.config.getMsgDataVersion(),Integer.MAX_VALUE));
		}
	}
	
	/** 连接逻辑服失败(逻辑线程) */
	public void connectGameFailed()
	{
		me.log("connectGameFailed");
		me.exitPassive();
	}
	
	/** 创建角色(每次序号递增) */
	public void createPlayer()
	{
		me.recordStep(RobotFlowStepType.CreatePlayer);
		
		me.send(CreatePlayerRequest.create(getCreatePlayerData()));
	}
	
	/** 创建角色数据 */
	protected CreatePlayerData getCreatePlayerData()
	{
		int index=++nameIndex;
		
		CreatePlayerData data=new CreatePlayerData();
		
		String uid=me.role.uid;
		
		data.name=uid+"_"+index;
		
		//data.name+='_'+"\uD83D\uDE00";
		
		//data.sex=MathUtils.randomBoolean() ? SexType.Boy : SexType.Girl;
		data.sex=SexType.Boy;
		data.vocation=VocationType.DefaultVocation;
		
		return data;
	}
	
	/** 创建角色成功 */
	public void onCreatePlayerSuccess(PlayerLoginData pData)
	{
		Ctrl.print("创建角色成功");
		
		playerLogin(pData.playerID);
	}
	
	/** 回复角色列表 */
	public void onRePlayerList(SList<PlayerLoginData> list)
	{
		cancelLoginFlow();
		
		me.recordStep(RobotFlowStepType.RePlayerList);
		
		if(list.isEmpty())
		{
			//Ctrl.print("列表为空需要创建:" + me.getInfo());
			createPlayer();
		}
		else
		{
			//Ctrl.print("有角色直接登录:" + me.getInfo());
			playerLogin(list.get(0).playerID);
		}
	}
	
	/** 角色登录 */
	public void playerLogin(long playerID)
	{
		startLoginFlow(LoginFlowType.PlayerLogin);
		
		me.recordStep(RobotFlowStepType.PlayerLogin);
		//登录
		me.send(PlayerLoginRequest.create(playerID));
	}
	
	/** 切换game服 */
	public void onSwitchGame(ClientLoginServerInfoData gameInfo)
	{
		Ctrl.print("切换game服",me.role.playerID,gameInfo.host,gameInfo.port);
		
		_gameInfo=gameInfo;
		
		_isSwitching=true;
		_server.close();
		_server.connectGame(gameInfo.host,gameInfo.port);
	}
	
	/** 收到信息 */
	public void onInfoCode(int code)
	{
		InfoCodeConfig config=InfoCodeConfig.get(code);
		
		Ctrl.print("收到服务器信息码",code,config.text);
		
		switch(code)
		{
			case InfoCodeType.LoginGameFailed_repeatLogin:
			case InfoCodeType.PlayerExit_crowedDown:
			case InfoCodeType.PlayerExit_beKicked:
			case InfoCodeType.PlayerExit_socketClose:
			case InfoCodeType.PlayerExit_serverClose:
			case InfoCodeType.PlayerExit_callSwitchBack:
			case InfoCodeType.PlayerExit_delete:
			{
				logout();
			}
				break;
			case InfoCodeType.PullBack_distance:
			{
				Ctrl.print("拉回by距离");
			}
				break;
		}
	}
	
	/** 登出(被动) */
	private void logout()
	{
		me.log("被动下线");
		
		cancelLoginFlow();
		
		me.exitPassive();
	}
	
	/** 收到服务器信息字符串 */
	public void onInfoString(int type,String str)
	{
		Ctrl.print("收到服务器信息字符串",type,str);
	}
	
	/** 获取保存boolean值 */
	public boolean getKeepBoolean(int key)
	{
		return _d.keepSave.booleanDic.get(key);
	}
	
	/** 获取保存int值 */
	public int getKeepInt(int key)
	{
		return _d.keepSave.intDic.get(key);
	}
	
	/** 获取保存string值 */
	public String getKeepString(String key)
	{
		return _d.keepSave.stringDic.get(key);
	}
	
	/** 保存baalean值 */
	public void saveKeepBoolean(int key,boolean value)
	{
		_d.keepSave.booleanDic.put(key,value);
		
		me.send(SaveBooleanRequest.create(key,value));
	}
	
	/** 保存baalean值 */
	public void saveKeepInt(int key,int value)
	{
		_d.keepSave.intDic.put(key,value);
		
		me.send(SaveIntRequest.create(key,value));
	}
	
	/** 保存baalean值 */
	public void saveKeepString(String key,String value)
	{
		_d.keepSave.stringDic.put(key,value);
		
		me.send(SaveStringRequest.create(key,value));
	}
	
	public void setServerTime(long serverTime)
	{
		_d.serverTime=serverTime;
		
		//查看下每个机器人都设置是否有影响
		DateControl.setCurrentTime(serverTime);
		
	}
	
	/** 获取种子序号 */
	public int getSeedIndex()
	{
		return _clientRandomIndex;
	}
	
	/** 设置种子序号 */
	public void setSeedIndex(int v)
	{
		_clientRandomIndex=v;
	}
	
	/** 设置登录链接 */
	public void setLoginURL(String value)
	{
		_loginURL=value;
	}
	
	/** 登录链接 */
	public String getLoginURL()
	{
		return _loginURL;
	}
	
	/** 获取下个客户端随机结果 */
	public boolean getClientRandom(int ratio)
	{
		int seed=_d.clientRandomSeeds[_clientRandomIndex];
		
		if(++_clientRandomIndex>=_d.clientRandomSeeds.length)
		{
			_clientRandomIndex=0;
		}
		
		return seed*10<ratio;
	}
	
	/** 检查进入初次场景 */
	public boolean checkEnterFirstScene()
	{
		if(_enteredFirstScene)
			return false;
		
		_enteredFirstScene=true;
		
		cancelLoginFlow();
		
		me.log("上线");
		
		me.onStart();
		
		return true;
	}
	
	/** 是否已经进入初次场景 */
	public boolean hasEnteredFirstScene()
	{
		return _enteredFirstScene;
	}
	
	public void startLoginFlow(int type)
	{
		_loginFlow=type;
		_loginTimeOut.start();
	}
	
	public void cancelLoginFlow()
	{
		_loginTimeOut.stop();
	}
	
	/** 登录流程超时 */
	private void loginFlowTimeOut()
	{
		me.errorLog("登录流程超时!!",_loginFlow);
	}
	
	/** 等待随机事件 */
	public void waitRandomAndLogin()
	{
		_timeDriver.setTimeOut(()->
		{
			//再登录
			startLogin();
			
		},MathUtils.randomRange(ClientGlobal.config.ints[0],ClientGlobal.config.ints[1]));
	}
	
	/** 登录测试 */
	public void testLogin()
	{
		_testLoginTimeOut.stop();
		
		_timeDriver.setTimeOut(()->
		{
			//断开连接
			if(ClientGlobal.config.bools[0])
			{
				me.exitInitialtive(false);
				dispose();
			}
			//直接下线
			else
			{
				me.exitInitialtive(false);
			}
			
			_timeDriver.setTimeOut(()->
			{
				_testLoginTimeOut.start();
				
				//再登录
				startLogin();
				
			},MathUtils.randomRange(ClientGlobal.config.ints[0],ClientGlobal.config.ints[1]));
			
		},MathUtils.randomRange(ClientGlobal.config.ints[0],ClientGlobal.config.ints[1]));
	}
	
	private void testLoginTimeOut()
	{
		me.errorLog("测试登录超时!!");
	}
	
	@Override
	protected BaseData createPartData()
	{
		return new SystemClientPartData();
	}
	
	public void recordResponse(GameResponse response)
	{
		if(response instanceof InitClientResponse)
		{
			_responseList.clear();
		}
		else
		{
			_responseList.add(response);
		}
	}
	
	public void setInited(boolean value)
	{
		_inited=value;
	}
	
	/** 是否初始化过 */
	public boolean inited()
	{
		return _inited;
	}
	
	/** 连接断开 */
	public void onSocketClose()
	{
		//连接中
		if(_isSwitching)
			return;
		
		//被动下线
		me.exitPassive();
	}
	
}
