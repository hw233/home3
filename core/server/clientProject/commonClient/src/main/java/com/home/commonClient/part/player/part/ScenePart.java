package com.home.commonClient.part.player.part;
import com.home.commonBase.data.scene.match.PlayerMatchData;
import com.home.commonBase.data.scene.scene.SceneEnterData;
import com.home.commonBase.data.scene.scene.ScenePreInfoData;
import com.home.commonBase.global.BaseC;
import com.home.commonBase.part.player.clientData.SceneClientPartData;
import com.home.commonClient.global.ClientGlobal;
import com.home.commonClient.net.request.func.match.FuncAcceptMatchRequest;
import com.home.commonClient.net.request.scene.scene.ApplyEnterSceneRequest;
import com.home.commonClient.net.request.scene.scene.PreEnterSceneReadyRequest;
import com.home.commonClient.part.player.base.PlayerBasePart;
import com.home.commonClient.scene.base.GameScene;
import com.home.shine.data.BaseData;
import com.home.shine.dataEx.AffairTimeOut;
import com.home.shine.utils.MathUtils;

/** 场景(generated by shine) */
public class ScenePart extends PlayerBasePart
{
	/** 数据 */
	private SceneClientPartData _d;
	
	/** 所在场景 */
	protected GameScene _scene;
	
	private int _preSceneID=-1;
	
	private int _preLineID=-1;
	
	/** 是否有下个场景 */
	private boolean _hasNextScene=false;
	
	/** 缓存场景预进入信息 */
	private ScenePreInfoData _infoData;
	
	/** 当前匹配的功能ID(-1就是没在匹配中) */
	private int _matchingFuncID=-1;
	
	private int _switchSceneFlow=0;
	
	private AffairTimeOut _switchSceneTimeOut=new AffairTimeOut(this::switchSceneTimeOut);
	
	@Override
	public void setData(BaseData data)
	{
		super.setData(data);
		
		_d=(SceneClientPartData)data;
	}
	
	/** 获取数据 */
	public SceneClientPartData getPartData()
	{
		return _d;
	}
	
	/** 构造函数(只在new后调用一次,再次从池中取出不会调用) */
	@Override
	public void construct()
	{
		
	}
	
	/** 构造数据前 */
	@Override
	protected void beforeMakeData()
	{
		
	}
	
	/** 初始化(创建后刚调用,与dispose成对) */
	@Override
	public void init()
	{
		
	}
	
	/** 析构(回池前调用,与init成对) */
	@Override
	public void dispose()
	{
		_matchingFuncID=-1;
		_preSceneID=-1;
		_preLineID=-1;
	}
	
	/** 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程) */
	@Override
	public void afterReadData()
	{
		
	}
	
	/** 每秒调用 */
	@Override
	public void onSecond(int delay)
	{
		_switchSceneTimeOut.onSecond();
	}
	
	/** 功能开启(id:功能ID) */
	@Override
	public void onFunctionOpen(int id)
	{
		
	}
	
	/** 功能关闭(id:功能ID) */
	@Override
	public void onFunctionClose(int id)
	{
		
	}
	
	@Override
	public void onLeave()
	{
		_switchSceneFlow=0;
		_switchSceneTimeOut.stop();
	}
	
	/** 每帧调用 */
	public void onFrame(int delay)
	{
		if(_scene!=null)
			_scene.onFrame(delay);
	}
	
	/** 获取所在场景 */
	public GameScene getScene()
	{
		return _scene;
	}
	
	/** 清除当前场景 */
	public void removeNowScene()
	{
		if(_scene!=null)
		{
			_scene.dispose();
			me.system.getExecutor().releaseScene(_scene);
			_scene=null;
		}
	}
	
	/** 预备进入场景 */
	public void onPreEnterScene(int sceneID,int lineID)
	{
		//Ctrl.print("预进入场景:",sceneID,me.getInfo());
		
		_preSceneID=sceneID;
		_preLineID=lineID;
	}
	
	public void onPreEnterSceneNext(ScenePreInfoData infoData)
	{
		//Ctrl.print("预进入场景:",infoData.id,me.getInfo());
		
		setSwitchSceneFlow(2);
		
		removeNowScene();
		
		_infoData=infoData;
		
		me.send(PreEnterSceneReadyRequest.create());
	}
	
	/** 进入场景 */
	public void onEnterScene(SceneEnterData enterData)
	{
		if(_preSceneID<=0)
		{
			me.errorLog("没有预备场景id");
			return;
		}
		
		_switchSceneTimeOut.stop();
		
		me.log("进入场景:",_preSceneID);
		
		removeNowScene();
		
		//已退出游戏
		if(me.system.isLeftGame)
			return;
		
		_scene=me.system.getExecutor().createScene(_preSceneID);
		
		_preSceneID=-1;
		_preLineID=-1;
		
		_scene.me=me;
		_scene.init();
		_scene.initEnterData(enterData);
		
		if(me.system.checkEnterFirstScene())
		{
		
		}
		else
		{
			if(BaseC.constlist.robotTestMode_needSwitchTown(ClientGlobal.mode))
			{
				testEnterScene();
			}
		}
	}
	
	/** 进入场景失败 */
	public void onEnterSceneFailed()
	{
		//TODO:进入场景失败的处理,等几秒再进
	}
	
	/** 是否当前不在场景中,并且没有下个场景 */
	public boolean isNoneScene()
	{
		return _scene==null && !_hasNextScene;
	}
	
	public boolean isMatching()
	{
		return _matchingFuncID!=-1;
	}
	
	public int getMatchingFuncID()
	{
		return _matchingFuncID;
	}
	
	public void setMatchingFuncID(int funcID)
	{
		_matchingFuncID=funcID;
	}
	
	/** 开始匹配消息 */
	public void onStartMatch(int funcID)
	{
		//Ctrl.print("开始匹配中,funcID:" + funcID,me.getInfo());
	}
	
	/** 匹配成功 */
	public void onMatchSuccess(int funcID,int index,PlayerMatchData[] matchDatas)
	{
		//Ctrl.print("匹配成功,funcID:" + funcID,me.getInfo());
		
		//进入指定场景
		me.send(FuncAcceptMatchRequest.create(funcID,index));
	}
	
	/** 取消匹配 */
	public void onCancelMatch(int funcID)
	{
		setMatchingFuncID(-1);
		
	}
	
	/** 离开场景回调 */
	public void onLeaveScene(boolean hasNext)
	{
	
	}
	
	protected void setSwitchSceneFlow(int type)
	{
		_switchSceneFlow=type;
		_switchSceneTimeOut.start();
	}
	
	protected void switchSceneTimeOut()
	{
		me.throwError("切换场景超时",_switchSceneFlow);
	}
	
	/** 测试进入场景 */
	public void testEnterScene()
	{
		if(ClientGlobal.config.sceneIDs.length>0)
		{
			int sceneID=MathUtils.randomFromIntArr(ClientGlobal.config.sceneIDs);
			
			//不是当前场景
			if(_scene==null || _scene.getConfig().id!=sceneID)
			{
				me.send(ApplyEnterSceneRequest.create(sceneID,-1,-1));
				setSwitchSceneFlow(1);
			}
		}
	}
	
	@Override
	protected BaseData createPartData()
	{
		return new SceneClientPartData();
	}
	
}
