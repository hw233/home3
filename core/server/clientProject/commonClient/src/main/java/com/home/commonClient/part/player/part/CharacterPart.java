package com.home.commonClient.part.player.part;
import com.home.commonBase.config.game.BuffConfig;
import com.home.commonBase.constlist.generate.BuffKeepType;
import com.home.commonBase.constlist.generate.FunctionType;
import com.home.commonBase.constlist.generate.ItemEquipActionType;
import com.home.commonBase.data.item.ItemData;
import com.home.commonBase.data.role.CharacterSaveData;
import com.home.commonBase.data.role.CharacterUseData;
import com.home.commonBase.data.role.MUnitSaveData;
import com.home.commonBase.data.role.MUnitUseData;
import com.home.commonBase.data.scene.base.BuffData;
import com.home.commonBase.global.BaseC;
import com.home.commonBase.global.CommonSetting;
import com.home.commonBase.logic.unit.UnitFightDataLogic;
import com.home.commonBase.part.player.clientData.CharacterClientPartData;
import com.home.commonClient.logic.unit.CharacterUseLogic;
import com.home.commonClient.logic.unit.MUnitUseLogic;
import com.home.commonClient.part.player.base.PlayerBasePart;
import com.home.commonClient.tool.func.PlayerEquipContainerTool;
import com.home.shine.ctrl.Ctrl;
import com.home.shine.data.BaseData;
import com.home.shine.global.ShineSetting;
import com.home.shine.support.collection.IntObjectMap;

/** 角色(generated by shine) */
public class CharacterPart extends PlayerBasePart
{
	/** 数据 */
	private CharacterClientPartData _d;
	
	/** 主角战斗数据逻辑组(全部) */
	private IntObjectMap<MUnitUseLogic> _mUnitUseLogics=new IntObjectMap<>(MUnitUseLogic[]::new);
	
	/** 出战中所有主单位 */
	private IntObjectMap<MUnitUseLogic> _mUnitUseLogicOnWorking=new IntObjectMap<>(MUnitUseLogic[]::new);
	
	@Override
	public void setData(BaseData data)
	{
		super.setData(data);
		
		_d=(CharacterClientPartData)data;
	}
	
	/** 获取数据 */
	public CharacterClientPartData getPartData()
	{
		return _d;
	}
	
	/** 构造函数(只在new后调用一次,再次从池中取出不会调用) */
	@Override
	public void construct()
	{
		
	}
	
	/** 构造数据前 */
	@Override
	protected void beforeMakeData()
	{
		
	}
	
	/** 初始化(创建后刚调用,与dispose成对) */
	@Override
	public void init()
	{
		
	}
	
	/** 析构(回池前调用,与init成对) */
	@Override
	public void dispose()
	{
		
	}
	
	/** 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程) */
	@Override
	public void afterReadData()
	{
		
	}
	
	/** 功能开启(id:功能ID) */
	@Override
	public void onFunctionOpen(int id)
	{
		
	}
	
	/** 功能关闭(id:功能ID) */
	@Override
	public void onFunctionClose(int id)
	{
		
	}
	
	public void onPiece(int delay)
	{
		//间隔拉长
		if(me.scene.isNoneScene() && !_mUnitUseLogics.isEmpty())
		{
			MUnitUseLogic[] values;
			MUnitUseLogic v;
			
			for(int i=(values=_mUnitUseLogics.getValues()).length-1;i>=0;--i)
			{
				if((v=values[i])!=null)
				{
					v.onPiece(delay);
				}
			}
		}
	}
	
	/** 添加角色战斗数据逻辑 */
	public void addMUnitUseLogic(MUnitUseLogic logic)
	{
		if(logic.index==-1)
		{
			me.throwError("未就绪的MUnitUseLogic");
		}
		
		if(_mUnitUseLogics.contains(logic.index))
		{
			me.throwError("重复的MUnitUseLogic"+logic.index);
		}
		
		_mUnitUseLogics.put(logic.index,logic);
		
		if(logic.isWorking())
		{
			_mUnitUseLogicOnWorking.put(logic.index,logic);
		}
	}
	
	/** 移除角色战斗数据逻辑 */
	public void removeMUnitUseLogic(MUnitUseLogic logic)
	{
		if(logic.index==-1)
		{
			Ctrl.throwError("未就绪的MUnitUseLogic");
		}
		
		_mUnitUseLogics.remove(logic.index);
		
		if(logic.isWorking())
		{
			_mUnitUseLogicOnWorking.remove(logic.index);
		}
	}
	
	/** 获取当前主单位使用逻辑(可能为空) */
	public MUnitUseLogic getMUnitUseLogic(int index)
	{
		return _mUnitUseLogics.get(index);
	}
	
	/** 通过saveData初始化useData */
	private void initMUnitUseBySave(MUnitUseData uData,MUnitSaveData sData)
	{
		uData.mIndex=sData.mIndex;
		uData.id=sData.id;
		uData.equips=sData.equips;//引用传递
	}
	
	protected void initCharacterUseBySave(CharacterUseData uData,CharacterSaveData sData)
	{
	
	}
	
	public CharacterUseData createCharacterUseDataBySaveData(CharacterSaveData saveData)
	{
		CharacterUseData data=BaseC.factory.createCharacterUseData();
		data.initDefault();
		
		//1级
		data.level=me.role.getLevel();
		initMUnitUseBySave(data,saveData);
		initCharacterUseBySave(data,saveData);
		
		return data;
	}
	
	public void initUseLogicByUseData(MUnitUseLogic logic,MUnitUseData useData,boolean isRobot,boolean needFuncTool)
	{
		//基础部分
		logic.init(useData,isRobot);
		
		if(isRobot)
		{
			//补满血蓝
			logic.getAttributeLogic().fillHpMp();
			//刷属性
			logic.getAttributeLogic().refreshAttributes();
		}
		else
		{
			logic.setPlayer(me);
			
			if(needFuncTool)
			{
				int funcID=logic.getMUnitFuncID(FunctionType.Equip);
				PlayerEquipContainerTool funcTool=toCreatePlayerEquipContainerTool(funcID);
				//互相绑定
				funcTool.setMUnitLogic(logic);
				logic.setEquipTool(funcTool);
				
				me.func.addFuncTool(funcTool,useData.equips);
			}
		}
	}
	
	protected PlayerEquipContainerTool toCreatePlayerEquipContainerTool(int funcID)
	{
		return new PlayerEquipContainerTool(funcID);
	}
	
	/** 获取所有出战单位 */
	public IntObjectMap<MUnitUseLogic> getMUnitUseLogicOnWorking()
	{
		return _mUnitUseLogicOnWorking;
	}
	
	/** 获取当前角色使用逻辑 */
	public CharacterUseLogic getCurrentCharacterUseLogic()
	{
		return null;
	}
	
	/** 获取主角单位数据逻辑 */
	public UnitFightDataLogic getMUnitFightDataLogic(int index)
	{
		return getMUnitUseLogic(index).getFightLogic();
	}
	
	@Override
	protected BaseData createPartData()
	{
		return new CharacterClientPartData();
	}
	
	private void doEquipActions(MUnitUseLogic logic,PlayerEquipContainerTool tool,int slot,int[][] actions,boolean isOn)
	{
		for(int i=0;i<actions.length;++i)
		{
			doOneEquipAction(logic,tool,slot,i,actions[i],isOn);
		}
	}
	
	protected void doOneEquipAction(MUnitUseLogic logic,PlayerEquipContainerTool tool,int slot,int index,int[] args,boolean isOn)
	{
		switch(args[0])
		{
			case ItemEquipActionType.AddBuff:
			{
				if(!CommonSetting.isClientDriveLogic)
					return;
				
				if(isOn)
				{
					if(ShineSetting.openCheck)
					{
						BuffConfig buffConfig=BuffConfig.get(args[0]);
						
						if(buffConfig.keepType!=BuffKeepType.Online)
						{
							Ctrl.throwError("装备用buff的保存类型必须为Online");
						}
					}
					
					BuffData buffData=logic.getBuffLogic().addBuff(args[0],args[1]);
					//记录buffID
					tool.getBuffInstanceIDDic().put(slot << CommonSetting.buffActionIndexOff | index,buffData.instanceID);
				}
				else
				{
					int instanceID=tool.getBuffInstanceIDDic().remove(slot << CommonSetting.buffActionIndexOff | index);
					
					if(instanceID<=0)
					{
						Ctrl.errorLog("不该找不到buff instanceID");
					}
					else
					{
						logic.getBuffLogic().removeBuffByInstanceID(instanceID);
					}
				}
			}
			break;
			case ItemEquipActionType.AddSkill:
			{
				if(!CommonSetting.isClientDriveLogic)
					return;
				
				if(isOn)
				{
					logic.getFightLogic().addSkill(args[0],args[1]);
				}
				else
				{
					logic.getFightLogic().removeSkill(args[0]);
				}
			}
			break;
		}
	}
	
	public void addEquipInfluence(MUnitUseLogic logic,PlayerEquipContainerTool tool,int slot,ItemData data)
	{
		if(CommonSetting.isClientDriveLogic)
		{
			logic.getAttributeLogic().addAttributes(data.config.baseAttributes);
		}
		
		doEquipActions(logic,tool,slot,data.config.equipActions,true);
	}
	
	public void removeEquipInfluence(MUnitUseLogic logic,PlayerEquipContainerTool tool,int slot,ItemData data)
	{
		if(CommonSetting.isClientDriveLogic)
		{
			logic.getAttributeLogic().subAttributes(data.config.baseAttributes);
		}
		
		doEquipActions(logic,tool,slot,data.config.equipActions,false);
	}
	
}
