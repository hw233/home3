package com.home.commonClient.part.player.part;
import com.home.commonBase.config.game.CurrencyConfig;
import com.home.commonBase.config.game.FunctionConfig;
import com.home.commonBase.config.game.QuestConfig;
import com.home.commonBase.config.game.RewardConfig;
import com.home.commonBase.config.game.RoleLevelConfig;
import com.home.commonBase.config.game.enumT.RoleShowDataPartTypeConfig;
import com.home.commonBase.constlist.generate.CurrencyType;
import com.home.commonBase.constlist.generate.GameEventType;
import com.home.commonBase.constlist.generate.InfoCodeType;
import com.home.commonBase.constlist.generate.PlatformType;
import com.home.commonBase.constlist.generate.RoleActionType;
import com.home.commonBase.constlist.generate.RoleConditionType;
import com.home.commonBase.constlist.generate.TaskType;
import com.home.commonBase.data.role.RoleShowChangeData;
import com.home.commonBase.data.role.RoleShowData;
import com.home.commonBase.global.BaseC;
import com.home.commonBase.global.CommonSetting;
import com.home.commonBase.global.Global;
import com.home.commonBase.part.player.clientData.RoleClientPartData;
import com.home.commonBase.scene.base.Unit;
import com.home.commonClient.logic.unit.CharacterUseLogic;
import com.home.commonClient.net.request.login.ApplyBindPlatformRequest;
import com.home.commonClient.part.player.base.PlayerBasePart;
import com.home.commonClient.scene.base.GameScene;
import com.home.shine.data.BaseData;
import com.home.shine.data.DIntData;
import com.home.shine.utils.ObjectUtils;

/** 玩家(generated by shine) */
public class RolePart extends PlayerBasePart
{
	/** 数据 */
	private RoleClientPartData _d;
	
	/** uid */
	public String uid;
	
	/** 用户ID */
	public int userID;
	
	/** 角色ID */
	public long playerID=-1;
	
	/** 角色名 */
	public String name="";
	
	/** 缓存角色显示数据 */
	private RoleShowData _selfRoleShowData;
	
	/** 货币上限组 */
	protected long[] _currenciesMax;
	
	@Override
	public void setData(BaseData data)
	{
		super.setData(data);
		
		_d=(RoleClientPartData)data;
	}
	
	/** 获取数据 */
	public RoleClientPartData getPartData()
	{
		return _d;
	}
	
	/** 构造函数(只在new后调用一次,再次从池中取出不会调用) */
	@Override
	public void construct()
	{
		//角色ID赋值
		_selfRoleShowData=BaseC.factory.createRoleShowData();
	}
	
	/** 构造数据前 */
	@Override
	protected void beforeMakeData()
	{
		
	}
	
	/** 初始化(创建后刚调用,与dispose成对) */
	@Override
	public void init()
	{
		
	}
	
	/** 析构(回池前调用,与init成对) */
	@Override
	public void dispose()
	{
		
	}
	
	/** 读库后前(先处理好主键) */
	public void afterReadDataFirst()
	{
		playerID=_d.playerID;
		name=_d.name;
	}
	
	/** 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程) */
	@Override
	public void afterReadData()
	{
		_d.currencies=ObjectUtils.ensureArrayLength(_d.currencies,CurrencyType.size);
		_d.currenciesMax=ObjectUtils.ensureArrayLength(_d.currenciesMax,CurrencyType.size);
		
		_currenciesMax=_d.currenciesMax;
	}
	
	@Override
	public void afterReadDataSecond()
	{
		makeRoleShowData(_selfRoleShowData);
	}
	
	/** 功能开启(id:功能ID) */
	@Override
	public void onFunctionOpen(int id)
	{
		
	}
	
	/** 功能关闭(id:功能ID) */
	@Override
	public void onFunctionClose(int id)
	{
		
	}
	
	/** 构造角色展示数据 */
	public void makeRoleShowData(RoleShowData data)
	{
		data.playerID=playerID;
		data.createAreaID=_d.createAreaID;
		data.name=name;
		
		data.sex=_d.sex;
		data.level=_d.level;
		data.vocation=_d.vocation;
	}
	
	/** 创建角色展示数据 */
	public RoleShowData createRoleShowData()
	{
		RoleShowData data=BaseC.factory.createRoleShowData();
		makeRoleShowData(data);
		return data;
	}
	
	/** 获取缓存角色展示数据(当前线程用) */
	public RoleShowData getSelfRoleShowData()
	{
		return _selfRoleShowData;
	}
	
	/** 性别 */
	public int getSex()
	{
		return _d.sex;
	}
	
	/** 玩家职业 */
	public int getVocation()
	{
		return _d.vocation;
	}
	
	/** 等级 */
	public int getLevel()
	{
		return _d.level;
	}
	
	public void addCurrencyMax(int type,long value)
	{
		_currenciesMax[type]+=value;
	}
	
	public void subCurrencyMax(int type,long value)
	{
		_currenciesMax[type]-=value;
	}
	
	public boolean isCurrencyMax(int type)
	{
		long max;
		return (max=_currenciesMax[type])>0 && _d.currencies[type]>=max;
	}
	
	public void addCurrency(int type,long value,int way)
	{
		if(value<=0)
			return;
		
		if(value<=0)
			return;
		
		long now=_d.currencies[type];
		long max;
		
		if((max=_currenciesMax[type])>0)
		{
			//达到上限
			if(now>=max)
			{
				return;
			}
			
			//本次可加值
			if(now+value>=max)
			{
				value=max-now;
			}
		}
		
		now=(_d.currencies[type]+=value);
		
		toLogAddCurrency(type,value,way);
		
		me.dispatch(GameEventType.RefreshCurrency,type);
		
		//需要增加记录
		if(CommonSetting.isClientDriveLogic && CurrencyConfig.get(type).needAddRecord)
		{
			int v2=(int)(_d.totalAddCurrencies[type]+=value);
			
			me.quest.taskEvent(TaskType.TotalAddCurrency,type,v2);
		}
		
		onAddCurrency(type,value);
	}
	
	public void addCurrencies(DIntData[] list,int way)
	{
		for(DIntData v : list)
		{
			addCurrency(v.key,v.value,way);
		}
	}
	
	/** 是否拥有货币组 */
	public boolean hasCurrencies(DIntData[] list)
	{
		return hasCurrencies(list,1);
	}
	
	/** 是否拥有货币组,num次 */
	public boolean hasCurrencies(DIntData[] list,int num)
	{
		for(DIntData v:list)
		{
			if(!hasCurrency(v.key,v.value*num))
				return false;
		}
		
		return true;
	}
	
	/** 是否有足够货币 */
	public boolean hasCurrency(int type,long value)
	{
		if(value<0)
			return false;
		
		return _d.currencies[type] >= value;
	}
	
	/** 获取货币 */
	public long getCurrency(int type)
	{
		return _d.currencies[type];
	}
	
	public void costCurrency(int type,long value,int way)
	{
		if(value<=0)
			return;
		
		long[] currencies;
		
		long v=(currencies=_d.currencies)[type];
		
		if((v-=value)<0)
		{
			value=v;
			v=0;
		}
		
		currencies[type]=v;
		
		toLogCostCurrency(type,value,way);
		
		me.dispatch(GameEventType.RefreshCurrency,type);
		
		if(CommonSetting.isClientDriveLogic && CurrencyConfig.get(type).needAddRecord)
		{
			me.quest.taskEvent(TaskType.TotalCostCurrency,type,(int)(_d.totalAddCurrencies[type]-_d.currencies[type]));
		}
		
		onCostCurrency(type,value);
	}
	
	/** 刷新货币 */
	public void onRefreshCurrency(int type,long value)
	{
		_d.currencies[type] = value;
		me.dispatch(GameEventType.RefreshCurrency,type);
	}
	
	public void addExp(long value,int way)
	{
		if(value<=0)
			return;
		
		int level;
		//已达最大等级
		if((level=_d.level) >= Global.levelMax)
		{
			return;
		}
		
		long v=(_d.exp+=value);
		
		long expMax;
		
		if(v >= (expMax=RoleLevelConfig.get(level).expMax))
		{
			int oldLevel=level;
			
			while(true)
			{
				v-=expMax;
				
				if(++level == Global.levelMax)
				{
					v=0;
					
					break;
				}
				
				expMax=RoleLevelConfig.get(level).expMax;
				
				if(v<expMax)
					break;
			}
			
			onRefreshExp(v);
			
			_d.level=level;
			
			me.onLevelUp(oldLevel);
		}
		else
		{
			onRefreshExp(v);
		}
	}
	
	/** 刷新经验 */
	public void onRefreshExp(long value)
	{
		_d.exp = value;
		me.dispatch(GameEventType.RefreshExp);
	}
	
	/** 升级消息 */
	public void levelUpByServer(int level)
	{
		int oldLevel = _d.level;
		_d.level = level;
		me.onLevelUp(oldLevel);
	}
	
	/** 更改名字消息 */
	public void onChangeName(String name)
	{
		_d.name=name;
		me.dispatch(GameEventType.RoleChangeName);
	}
	
	protected void toLogAddCurrency(int type,long value,int way)
	{
		//ClientC.log.playerAddCurrency(me,type,value,way);
	}
	
	protected void toLogCostCurrency(int type,long value,int way)
	{
		//ClientC.log.playerCostCurrency(me,type,value,way);
	}
	
	protected void onAddCurrency(int type,long value)
	{
	
	}
	
	protected void onCostCurrency(int type,long value)
	{
	
	}
	
	@Override
	public void onLevelUp(int oldLevel)
	{
		me.quest.questConditionChanged();
	}
	
	/** 申请绑定平台 */
	public void applyBindPlatform(String uid,String platform)
	{
		if(!_d.platform.equals(PlatformType.Visitor))
		{
			me.warnLog("游客平台不能绑定");
			return;
		}
		
		if(platform.equals(PlatformType.Visitor))
		{
			me.warnLog("游客平台不能绑定");
			return;
		}
		
		me.send(ApplyBindPlatformRequest.create(uid,platform));
	}
	
	/** 绑定平台结果 */
	public void onBindPlatform(String uid,String platform)
	{
		_d.uid=uid;
		_d.platform=platform;
		
		me.dispatch(GameEventType.BindPlatformSuccess);
	}
	
	@Override
	protected BaseData createPartData()
	{
		return new RoleClientPartData();
	}
	
	public void refreshPartRoleShowData(int type,int value)
	{
		RoleShowChangeData data=new RoleShowChangeData();
		data.type=type;
		data.arg0=value;
		
		refreshPartRoleShowData(data);
	}
	
	public void refreshPartRoleShowData(int type,String value)
	{
		RoleShowChangeData data=new RoleShowChangeData();
		data.type=type;
		data.arg1=value;
		
		refreshPartRoleShowData(data);
	}
	
	public void refreshPartRoleShowData(RoleShowChangeData data)
	{
		//先改自己的
		_selfRoleShowData.onChange(data);
		
		GameScene scene=me.scene.getScene();
		
		//场景部分
		Unit unit;
		
		if(scene!=null && (unit=scene.getHero())!=null)
		{
			//非社交部分
			if(!RoleShowDataPartTypeConfig.get(data.type).isSocialPart)
			{
				RoleShowData roleShowData=unit.getUnitData().getCharacterIdentity().roleShowData;
				
				roleShowData.onChange(data);
			}
		}
		
		//社交部分
		// me.social.refreshRoleSocialData(data);
	}
	
	/** 检查角色条件一组 */
	public boolean checkRoleConditions(int[][] args,boolean needNotice)
	{
		for(int[] v : args)
		{
			if(!checkOneRoleCondition(v,needNotice))
			{
				return false;
			}
		}
		
		return true;
	}
	
	/** 检查单个角色条件 */
	public boolean checkOneRoleCondition(int[] args,boolean needNotice)
	{
		switch(args[0])
		{
			case RoleConditionType.Level:
			{
				if(me.role.getLevel()<args[1])
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_needLevel);
					
					return false;
				}
			}
			break;
			case RoleConditionType.FunctionOpen:
			{
				if(!me.func.isFunctionOpen(args[1]))
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_functionNotOpen,FunctionConfig.get(args[1]).showName);
					
					return false;
				}
			}
			break;
			case RoleConditionType.NeedUnion:
			{
				if(!me.union.hasUnion())
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_needUnion);
					
					return false;
				}
			}
			break;
			case RoleConditionType.QuestComplete:
			{
				if(!me.quest.isQuestComplete(args[1]))
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_needCompleteQuest,QuestConfig.get(args[1]).name);
					
					return false;
				}
			}
			case RoleConditionType.OnStatus:
			{
				if(!me.character.getCurrentCharacterUseLogic().getFightLogic().status.getStatus(args[1]))
				{
					
					return false;
				}
			}
			break;
			case RoleConditionType.OffStatus:
			{
				if(me.character.getCurrentCharacterUseLogic().getFightLogic().status.getStatus(args[1]))
				{
					
					return false;
				}
			}
			break;
		}
		
		return true;
	}
	
	/** 执行动作组 */
	public void doRoleActions(int[][] actions,int num,int way)
	{
		if(!CommonSetting.isClientDriveLogic)
			return;
		
		for(int[] v : actions)
		{
			me.role.doOneRoleAction(v,num,way);
		}
	}
	
	/** 执行单个动作 */
	public void doOneRoleAction(int[] args,int num,int way)
	{
		if(!CommonSetting.isClientDriveLogic)
			return;
		
		switch(args[0])
		{
			case RoleActionType.HeroAddAttribute:
			{
				CharacterUseLogic logic;
				
				if((logic=me.character.getCurrentCharacterUseLogic())!=null)
				{
					logic.getAttributeLogic().addOneAttribute(args[1],args[2]*num);
				}
			}
				break;
			case RoleActionType.HeroAddAttributeVar:
			{
				CharacterUseLogic logic;
				
				if((logic=me.character.getCurrentCharacterUseLogic())!=null)
				{
					logic.getAttributeLogic().addOneAttribute(args[1],logic.getFightLogic().getSkillVarValue(args[2])*num);
				}
			}
				break;
			case RoleActionType.HeroAddBuff:
			{
				CharacterUseLogic logic;
				
				if((logic=me.character.getCurrentCharacterUseLogic())!=null)
				{
					logic.getBuffLogic().addBuff(args[1],args[2]);//buff只加一次
				}
			}
				break;
			case RoleActionType.AddCurrency:
			{
				me.role.addCurrency(args[1],args[2]*num,way);
			}
				break;
			case RoleActionType.AddReward:
			{
				for(int i=0;i<num;++i)
				{
					me.bag.addReward(args[1],way);
				}
			}
				break;
		}
	}
	
	/** 执行单个道具物品动作 */
	public boolean checkOneRoleConditionForAction(int[] args,int num)
	{
		switch(args[0])
		{
			case RoleActionType.AddReward:
			{
				RewardConfig rewardConfig=RewardConfig.get(args[1]);
				//只看空余格子
				return me.bag.hasFreeGrid(rewardConfig.needGrid*num);
			}
		}
		
		return true;
	}
	
}
