using ShineEngine;

namespace ShineEngine
{
	/// <summary>
	/// 时间经过数据(generated by shine)
	/// </summary>
	public class TimePassData:BaseData
	{
		/// <summary>
		/// 数据类型ID
		/// </summary>
		public const int dataID=ShineDataType.TimePass;
		
		protected long _lastCheckTime;
		
		/// <summary>
		/// 走过的时间
		/// </summary>
		public int timePass;
		
		/// <summary>
		/// 时间上限
		/// </summary>
		public int timeMax;
		
		/** 是否暂停(不写入) */
		private bool _isPause=false;
		
		/** 是否将超出的经过时间回归 */
		private bool _needCut=true;
		
		public TimePassData()
		{
			_dataID=ShineDataType.TimePass;
		}
		
		/// <summary>
		/// 读取字节流(完整版)
		/// </summary>
		protected override void toReadBytesFull(BytesReadStream stream)
		{
			stream.startReadObj();
			
			this.timePass=stream.readInt();
			
			this.timeMax=stream.readInt();
			
			stream.endReadObj();
		}
		
		/// <summary>
		/// 写入字节流(完整版)
		/// </summary>
		protected override void toWriteBytesFull(BytesWriteStream stream)
		{
			stream.startWriteObj();
			
			stream.writeInt(this.timePass);
			
			stream.writeInt(this.timeMax);
			
			stream.endWriteObj();
		}
		
		/// <summary>
		/// 读取字节流(简版)
		/// </summary>
		protected override void toReadBytesSimple(BytesReadStream stream)
		{
			this.timePass=stream.readInt();
			
			this.timeMax=stream.readInt();
			
		}
		
		/// <summary>
		/// 写入字节流(简版)
		/// </summary>
		protected override void toWriteBytesSimple(BytesWriteStream stream)
		{
			stream.writeInt(this.timePass);
			
			stream.writeInt(this.timeMax);
			
		}
		
		protected override void beforeWrite()
		{
			runTime();
		}
		
		protected override void afterRead()
		{
			//修复逻辑
			if(timePass<0)
			{
				timePass=0;
			}

			_lastCheckTime=DateControl.getTimeMillis();
		}
		
		public void init(int timeMax)
		{
			this.timeMax=timeMax;
			reStart();
		}
		
		public override void clear()
		{
			timeMax=-1;
			reStart();
		}
		
		public bool isNone()
		{
			return timeMax==-1;
		}
		
		public virtual void reStart()
		{
			timePass=0;
			_lastCheckTime=DateControl.getTimeMillis();
		}
		
		public void setOver()
		{
			//		setTimeMax(getTimeMax());

			addTimePass(getLastTime());
		}
		
		public void pause(bool value)
		{
			if(_isPause==value)
				return;

			runTime();

			_isPause=value;
		}
		
		public void setNeedCut(bool value)
		{
			if(_needCut==value)
				return;

			_needCut=value;

			runTime();

			checkAddMax();
		}
		
		public void addTimeMax(int addTimeMax)
		{
			setTimeMax(timeMax + addTimeMax);
		}
		
		public void setTimeMax(int timeMax)
		{
			runTime();

			this.timeMax=timeMax;

			checkAddMax();
		}
		
		public int getTimePass()
		{
			runTime();

			return timePass;
		}
		
		public void addTimePass(int time)
		{
			runTime();

			if(!isNone())
			{
				timePass+=time;

				checkAddMax();
			}
		}
		
		public void disTimePass(int time)
		{
			runTime();

			if(!isNone())
			{
				timePass-=time;

				checkAddMax();
			}
		}
		
		public int getLastTime()
		{
			runTime();

			if(isNone())
				return 0;

			//超时返回0
			if(timePass>=timeMax)
			{
				return 0;
			}

			return timeMax - timePass;
		}
		
		public bool isOver()
		{
			runTime();

			if(isNone())
				return false;

			return timePass<0 || timePass>=timeMax;
		}
		
		public void runTime()
		{
			long time=DateControl.getTimeMillis();

			if(!isNone())
			{
				//未暂停
				if(!_isPause)
				{
					int delay=(int)(time - _lastCheckTime);

					if(delay>0)
					{
						toAddTime(delay);
						checkAddMax();
					}
				}
			}

			_lastCheckTime=time;
		}
		
		protected virtual void toAddTime(int delay)
		{
			timePass+=delay;
		}
		
		private void checkAddMax()
		{
			if(_needCut && timeMax>0 && timePass>timeMax)
			{
				timePass=timeMax;
			}
		}
		
		public void fullTime()
		{
			if(timeMax<0)
				return;

			addTimePass(timeMax);
		}
		
		/// <summary>
		/// 创建并开始计时
		/// </summary>
		public static TimePassData create(int timeMax)
		{
			TimePassData re=new TimePassData();
			re.timeMax=timeMax;
			re.reStart();

			return re;
		}
		
		/// <summary>
		/// 创建一个结束计时的
		/// </summary>
		public static TimePassData createForOver(int timeMax)
		{
			TimePassData re=new TimePassData();
			re.timeMax=timeMax;
			re.timePass=timeMax;
			re._lastCheckTime=DateControl.getTimeMillis();

			return re;
		}
		
		/// <summary>
		/// 获取数据类名
		/// </summary>
		public override string getDataClassName()
		{
			return "TimePassData";
		}
		
		/// <summary>
		/// 复制(潜拷贝)
		/// </summary>
		protected override void toShadowCopy(BaseData data)
		{
			if(!(data is TimePassData))
				return;
			
			TimePassData mData=(TimePassData)data;
			
			this.timePass=mData.timePass;
			this.timeMax=mData.timeMax;
		}
		
		/// <summary>
		/// 复制(深拷贝)
		/// </summary>
		protected override void toCopy(BaseData data)
		{
			if(!(data is TimePassData))
				return;
			
			TimePassData mData=(TimePassData)data;
			
			this.timePass=mData.timePass;
			
			this.timeMax=mData.timeMax;
			
		}
		
		/// <summary>
		/// 是否数据一致
		/// </summary>
		protected override bool toDataEquals(BaseData data)
		{
			TimePassData mData=(TimePassData)data;
			if(this.timePass!=mData.timePass)
				return false;
			
			if(this.timeMax!=mData.timeMax)
				return false;
			
			return true;
		}
		
		/// <summary>
		/// 转文本输出
		/// </summary>
		protected override void toWriteDataString(DataWriter writer)
		{
			writer.writeTabs();
			writer.sb.Append("timePass");
			writer.sb.Append(':');
			writer.sb.Append(this.timePass);
			
			writer.writeEnter();
			writer.writeTabs();
			writer.sb.Append("timeMax");
			writer.sb.Append(':');
			writer.sb.Append(this.timeMax);
			
			writer.writeEnter();
		}
		
		/// <summary>
		/// 初始化初值
		/// </summary>
		public override void initDefault()
		{
			
		}
		
		/// <summary>
		/// 回池
		/// </summary>
		protected override void toRelease(DataPool pool)
		{
			this.timePass=0;
			this.timeMax=0;
		}
		
	}
}
