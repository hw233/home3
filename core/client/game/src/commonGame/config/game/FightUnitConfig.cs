using ShineEngine;

/// <summary>
/// 战斗单位表(generated by shine)
/// </summary>
public class FightUnitConfig:BaseConfig
{
	/** 存储集合 */
	private static IntObjectMap<FightUnitConfig> _dic;
	
	/// <summary>
	/// id
	/// </summary>
	public int id;
	
	/// <summary>
	/// 攻击距离类型
	/// </summary>
	public int attackRange;
	
	/// <summary>
	/// 特效ID
	/// </summary>
	public int effectID;
	
	/// <summary>
	/// 模型ID
	/// </summary>
	public int modelID;
	
	/// <summary>
	/// 所属组
	/// </summary>
	public int[] groups;
	
	/// <summary>
	/// 死亡保留时间(ms)
	/// </summary>
	public int deathKeepTime;
	
	/// <summary>
	/// 复活等待时间(ms)
	/// </summary>
	public int reviveWaitTime;
	
	/// <summary>
	/// 所属职业
	/// </summary>
	public int vocation;
	
	/// <summary>
	/// 默认AI指令
	/// </summary>
	public int defaultAICommand;
	
	/// <summary>
	/// 默认AI模式
	/// </summary>
	public int defaultAIMode;
	
	/// <summary>
	/// 是否在待机状态下游荡
	/// </summary>
	public bool isWanderOnIdle;
	
	/// <summary>
	/// 被动攻击半径
	/// </summary>
	public float passiveAttackRadius;
	
	/// <summary>
	/// 被动攻击半径平方
	/// </summary>
	public float passiveAttackRadiusT;
	
	/// <summary>
	/// 主动攻击半径
	/// </summary>
	public float initiativeAttackRadius;
	
	/// <summary>
	/// 主动攻击半径平方
	/// </summary>
	public float initiativeAttackRadiusT;
	
	/// <summary>
	/// 最大追击半径
	/// </summary>
	public float maxPursueRadius;
	
	/// <summary>
	/// 唤醒同伴半径
	/// </summary>
	public float wakeUpCompanionAttackRadius;
	
	public float wakeUpCompanionAttackRadiusT;
	
	/// <summary>
	/// 跟随半径
	/// </summary>
	public float followRadius;
	
	/// <summary>
	/// 跟随半径平方
	/// </summary>
	public float followRadiusT;
	
	/// <summary>
	/// 驾驶方式转向角速度(角度/s)
	/// </summary>
	public float driveAngleSpeed;
	
	/// <summary>
	/// 驾驶方式转向角速度(弧度/ms)
	/// </summary>
	public float driveDirectionSpeedT;
	
	/// <summary>
	/// 驾驶方式转向半径
	/// </summary>
	public float driveTurnRadius;
	
	/// <summary>
	/// 可攻击目标类型
	/// </summary>
	public int[] attackInfluenceType;
	
	/// <summary>
	/// 驾驶方式是否可原地转向
	/// </summary>
	public bool canDriveTurnAtPivot;
	
	/// <summary>
	/// 地图移动类型
	/// </summary>
	public int mapMoveType;
	
	/// <summary>
	/// 走跑移速比率
	/// </summary>
	public float walkSpeedRatio;
	
	/// <summary>
	/// 是否使用驾驶方式移动
	/// </summary>
	public bool needDrive;
	
	/// <summary>
	/// 是否启用仇恨目标切换
	/// </summary>
	public bool needHateSwitchTarget;
	
	/// <summary>
	/// 驾驶方式加速度
	/// </summary>
	public int driveAccelerateSpeed;
	
	/// <summary>
	/// 可攻击目标类型
	/// </summary>
	public bool[] attackInfluenceTypeT;
	
	/// <summary>
	/// 复活方式
	/// </summary>
	public int reviveType;
	
	/// <summary>
	/// 等级上限
	/// </summary>
	public int levelMax;
	
	/// <summary>
	/// 获取
	/// </summary>
	public static FightUnitConfig get(int id)
	{
		return _dic.get(id);
	}
	
	/// <summary>
	/// 设置字典
	/// </summary>
	public static void setDic(IntObjectMap<FightUnitConfig> dic)
	{
		_dic=dic;
	}
	
	/// <summary>
	/// 添加字典(热更用)
	/// </summary>
	public static void addDic(IntObjectMap<FightUnitConfig> dic)
	{
		_dic.putAll(dic);
	}
	
	/// <summary>
	/// 获取全部
	/// </summary>
	public static IntObjectMap<FightUnitConfig> getDic()
	{
		return _dic;
	}
	
	/// <summary>
	/// 读取字节流(简版)
	/// </summary>
	protected override void toReadBytesSimple(BytesReadStream stream)
	{
		base.toReadBytesSimple(stream);
		
		this.id=stream.readInt();
		
		this.attackRange=stream.readInt();
		
		this.modelID=stream.readInt();
		
		this.effectID=stream.readInt();
		
		this.vocation=stream.readInt();
		
		int groupsLen=stream.readLen();
		if(this.groups==null || this.groups.Length!=groupsLen)
		{
			this.groups=new int[groupsLen];
		}
		int[] groupsT=this.groups;
		for(int groupsI=0;groupsI<groupsLen;++groupsI)
		{
			int groupsV;
			groupsV=stream.readInt();
			
			groupsT[groupsI]=groupsV;
		}
		
		this.deathKeepTime=stream.readInt();
		
		this.reviveWaitTime=stream.readInt();
		
		this.reviveType=stream.readInt();
		
		this.isWanderOnIdle=stream.readBoolean();
		
		this.defaultAIMode=stream.readInt();
		
		this.defaultAICommand=stream.readInt();
		
		this.initiativeAttackRadius=stream.readFloat();
		
		this.passiveAttackRadius=stream.readFloat();
		
		this.maxPursueRadius=stream.readFloat();
		
		this.wakeUpCompanionAttackRadius=stream.readFloat();
		
		this.followRadius=stream.readFloat();
		
		int attackInfluenceTypeLen=stream.readLen();
		if(this.attackInfluenceType==null || this.attackInfluenceType.Length!=attackInfluenceTypeLen)
		{
			this.attackInfluenceType=new int[attackInfluenceTypeLen];
		}
		int[] attackInfluenceTypeT=this.attackInfluenceType;
		for(int attackInfluenceTypeI=0;attackInfluenceTypeI<attackInfluenceTypeLen;++attackInfluenceTypeI)
		{
			int attackInfluenceTypeV;
			attackInfluenceTypeV=stream.readInt();
			
			attackInfluenceTypeT[attackInfluenceTypeI]=attackInfluenceTypeV;
		}
		
		this.mapMoveType=stream.readInt();
		
		this.walkSpeedRatio=stream.readFloat();
		
		this.needDrive=stream.readBoolean();
		
		this.driveAngleSpeed=stream.readFloat();
		
		this.driveAccelerateSpeed=stream.readInt();
		
		this.driveTurnRadius=stream.readFloat();
		
		this.canDriveTurnAtPivot=stream.readBoolean();
		
		this.needHateSwitchTarget=stream.readBoolean();
		
	}
	
	protected override void afterReadConfig()
	{
		base.afterReadConfig();

		passiveAttackRadiusT=passiveAttackRadius * passiveAttackRadius;
		initiativeAttackRadiusT=initiativeAttackRadius * initiativeAttackRadius;
		followRadiusT=followRadius * followRadius;
		wakeUpCompanionAttackRadiusT=wakeUpCompanionAttackRadius * wakeUpCompanionAttackRadius;
		attackInfluenceTypeT=SkillInfluenceTypeConfig.getInfluenceSet(attackInfluenceType);
		driveDirectionSpeedT=MathUtils.angleToDirection(driveAngleSpeed)/1000f;
	}
	
	/// <summary>
	/// 读完所有表后处理
	/// </summary>
	public static void afterReadConfigAll()
	{
		
	}
	
	/// <summary>
	/// 写入字节流(简版)
	/// </summary>
	protected override void toWriteBytesSimple(BytesWriteStream stream)
	{
		base.toWriteBytesSimple(stream);
		
		stream.writeInt(this.id);
		
		stream.writeInt(this.attackRange);
		
		stream.writeInt(this.modelID);
		
		stream.writeInt(this.effectID);
		
		stream.writeInt(this.vocation);
		
		if(this.groups!=null)
		{
			int[] groupsT=this.groups;
			stream.writeLen(groupsT.Length);
			for(int groupsVI=0,groupsVLen=groupsT.Length;groupsVI<groupsVLen;++groupsVI)
			{
				int groupsV=groupsT[groupsVI];
				stream.writeInt(groupsV);
				
			}
		}
		else
		{
			nullObjError("groups");
		}
		
		stream.writeInt(this.deathKeepTime);
		
		stream.writeInt(this.reviveWaitTime);
		
		stream.writeInt(this.reviveType);
		
		stream.writeBoolean(this.isWanderOnIdle);
		
		stream.writeInt(this.defaultAIMode);
		
		stream.writeInt(this.defaultAICommand);
		
		stream.writeFloat(this.initiativeAttackRadius);
		
		stream.writeFloat(this.passiveAttackRadius);
		
		stream.writeFloat(this.maxPursueRadius);
		
		stream.writeFloat(this.wakeUpCompanionAttackRadius);
		
		stream.writeFloat(this.followRadius);
		
		if(this.attackInfluenceType!=null)
		{
			int[] attackInfluenceTypeT=this.attackInfluenceType;
			stream.writeLen(attackInfluenceTypeT.Length);
			for(int attackInfluenceTypeVI=0,attackInfluenceTypeVLen=attackInfluenceTypeT.Length;attackInfluenceTypeVI<attackInfluenceTypeVLen;++attackInfluenceTypeVI)
			{
				int attackInfluenceTypeV=attackInfluenceTypeT[attackInfluenceTypeVI];
				stream.writeInt(attackInfluenceTypeV);
				
			}
		}
		else
		{
			nullObjError("attackInfluenceType");
		}
		
		stream.writeInt(this.mapMoveType);
		
		stream.writeFloat(this.walkSpeedRatio);
		
		stream.writeBoolean(this.needDrive);
		
		stream.writeFloat(this.driveAngleSpeed);
		
		stream.writeInt(this.driveAccelerateSpeed);
		
		stream.writeFloat(this.driveTurnRadius);
		
		stream.writeBoolean(this.canDriveTurnAtPivot);
		
		stream.writeBoolean(this.needHateSwitchTarget);
		
	}
	
	/// <summary>
	/// 是否包含某组
	/// </summary>
	public bool hasGroup(int groupID)
	{
		int[] groups;

		for(int i=(groups=this.groups).Length-1;i>=0;--i)
		{
			if(groups[i]==groupID)
				return true;
		}

		return false;
	}
	
}
