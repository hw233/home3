using ShineEngine;

/// <summary>
/// 宠物(generated by shine)
/// </summary>
public class PetPart:PlayerBasePart
{
	/** 数据 */
	private PetPartData _d;
	
	private IntObjectMap<PetUseLogic> _petDic=new IntObjectMap<PetUseLogic>();
	
	private IntObjectMap<PetUseLogic> _petDicByID;
	
	public override void setData(BaseData data)
	{
		base.setData(data);
		
		_d=(PetPartData)data;
	}
	
	/// <summary>
	/// 获取数据
	/// </summary>
	public PetPartData getPartData()
	{
		return _d;
	}
	
	protected override BaseData createPartData()
	{
		return new PetPartData();
	}
	
	/// <summary>
	/// 初始化(创建后刚调用,与dispose成对)
	/// </summary>
	public override void init()
	{
		
	}
	
	/// <summary>
	/// 析构(回池前调用,与init成对)
	/// </summary>
	public override void dispose()
	{
		_petDic.forEachValueAndClear(v=>
		{
			v.dispose();
			GameC.pool.petUseLogicPool.back(v);
		});

		if(Global.isPetUnique)
		{
			_petDicByID.clear();
		}
	}
	
	/// <summary>
	/// 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程)
	/// </summary>
	public override void afterReadData()
	{
		PetUseData[] values;
		PetUseData v;

		for(int i=(values=_d.petDic.getValues()).Length-1;i>=0;--i)
		{
			if((v=values[i])!=null)
			{
				PetUseLogic logic=GameC.pool.petUseLogicPool.getOne();
				initPetUseLogicByUseData(logic,v);
			}
		}
	}
	
	/// <summary>
	/// 构造函数(只在new后调用一次,再次从池中取出不会调用)
	/// </summary>
	public override void construct()
	{
		
	}
	
	/// <summary>
	/// 构造数据前
	/// </summary>
	protected override void beforeMakeData()
	{
		
	}
	
	/// <summary>
	/// 功能开启(id:功能ID)
	/// </summary>
	public override void onFunctionOpen(int id)
	{
		
	}
	
	/// <summary>
	/// 功能关闭(id:功能ID)
	/// </summary>
	public override void onFunctionClose(int id)
	{
		
	}
	
	public void initPetUseLogicByUseData(PetUseLogic logic,PetUseData useData)
	{
		me.character.initUseLogicByUseData(logic,useData,Global.isPetNeedEquip,true,false);

		_petDic.put(logic.index,logic);

		if(Global.isPetUnique)
		{
			if(_petDicByID.contains(useData.id))
			{
				me.errorLog("已存在的宠物数据");
			}

			_petDicByID.put(useData.id,logic);
		}
	}
	
	/// <summary>
	/// 获取宠物
	/// </summary>
	public PetUseLogic getPet(int mIndex)
	{
		return _petDic.get(mIndex);
	}
	
	/// <summary>
	/// 检查当前是否可出战
	/// </summary>
	protected virtual bool checkCanWork(PetUseLogic logic)
	{
		return true;
	}
	
	/// <summary>
	/// 添加宠物
	/// </summary>
	public void addPet(PetUseData data)
	{
		_d.petDic.put(data.mIndex,data);

		PetUseLogic logic=GameC.pool.petUseLogicPool.getOne();

		initPetUseLogicByUseData(logic,data);

		me.dispatch(GameEventType.AddPet,data.mIndex);
	}
	
	/// <summary>
	/// 删除宠物
	/// </summary>
	public void removePet(int index)
	{
		PetUseLogic logic=getPet(index);

		if(logic==null)
		{
			me.warnLog("删除宠物时，未找到",index);
			return;
		}

		int id=logic.getData().id;

		logic.dispose();

		_d.petDic.remove(index);
		_petDic.remove(index);

		if(Global.isPetUnique)
		{
			_petDicByID.remove(id);
		}

		GameC.pool.petUseLogicPool.back(logic);

		me.dispatch(GameEventType.RemovePet,index);
	}
	
	/// <summary>
	/// 宠物出战
	/// </summary>
	public void petWork(int mIndex)
	{
		PetUseLogic logic=getPet(mIndex);

		if(logic==null)
		{
			me.showInfoCode(InfoCodeType.PetWork_notExist);
			return;
		}

		if(logic.isWorking())
		{
			me.showInfoCode(InfoCodeType.PetWork_isWorkingNow);
			return;
		}

		if(!checkCanWork(logic))
		{
			me.showInfoCode(InfoCodeType.PetWork_cantWork);
			return;
		}

		me.send(PetWorkRequest.create(logic.index));
	}
	
	/// <summary>
	/// 宠物休息
	/// </summary>
	public void petRest(int mIndex)
	{
		PetUseLogic logic=getPet(mIndex);

		if(logic==null)
		{
			me.showInfoCode(InfoCodeType.PetReset_notExist);
			return;
		}

		if(!logic.isWorking())
		{
			me.showInfoCode(InfoCodeType.PetReset_isNotWorkingNow);
			return;
		}

		me.send(PetRestRequest.create(mIndex));
	}
	
	/// <summary>
	/// 宠物出战状态修改
	/// </summary>
	public void onPetWorkingChange(int mIndex,bool isWorking)
	{
		PetUseLogic logic=getPet(mIndex);

		if(logic==null)
		{
			me.warnLog("宠物出战时,找不到宠物");
			return;
		}

		logic.setIsWorking(isWorking);

		me.dispatch(GameEventType.PetIsWorkingChange,mIndex);
	}
	
}
