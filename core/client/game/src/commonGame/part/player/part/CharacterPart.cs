using ShineEngine;

/// <summary>
/// 角色(generated by shine)
/// </summary>
public class CharacterPart:PlayerBasePart
{
	/** 数据 */
	private CharacterPartData _d;
	
	/** 主角战斗数据逻辑组(全部) */
	private IntObjectMap<MUnitUseLogic> _mUnitUseLogics=new IntObjectMap<MUnitUseLogic>();
	
	/** 出战中所有主单位 */
	private IntObjectMap<MUnitUseLogic> _mUnitUseLogicOnWorking=new IntObjectMap<MUnitUseLogic>();
	
	public override void setData(BaseData data)
	{
		base.setData(data);
		
		_d=(CharacterPartData)data;
	}
	
	/// <summary>
	/// 获取数据
	/// </summary>
	public CharacterPartData getPartData()
	{
		return _d;
	}
	
	/// <summary>
	/// 构造函数(只在new后调用一次,再次从池中取出不会调用)
	/// </summary>
	public override void construct()
	{

	}
	
	/// <summary>
	/// 构造数据前
	/// </summary>
	protected override void beforeMakeData()
	{
		
	}
	
	/// <summary>
	/// 初始化(创建后刚调用,与dispose成对)
	/// </summary>
	public override void init()
	{
	}
	
	/// <summary>
	/// 析构(回池前调用,与init成对)
	/// </summary>
	public override void dispose()
	{
	}
	
	/// <summary>
	/// 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程)
	/// </summary>
	public override void afterReadData()
	{

	}
	
	/// <summary>
	/// 配置表更新后(配置替换)
	/// </summary>
	public override void onReloadConfig()
	{
		_mUnitUseLogics.forEachValue(v=>
		{
			v.getFightLogic().reloadConfig();
		});
	}
	
	/// <summary>
	/// 功能开启(id:功能ID)
	/// </summary>
	public override void onFunctionOpen(int id)
	{

	}
	
	/// <summary>
	/// 功能关闭(id:功能ID)
	/// </summary>
	public override void onFunctionClose(int id)
	{

	}
	
	/// <summary>
	/// 添加角色战斗数据逻辑
	/// </summary>
	public void addMUnitUseLogic(MUnitUseLogic logic)
	{
		if(logic.index==-1)
		{
			me.throwError("未就绪的MUnitUseLogic");
		}

		if(_mUnitUseLogics.contains(logic.index))
		{
			me.throwError("重复的MUnitUseLogic"+logic.index);
		}

		_mUnitUseLogics.put(logic.index,logic);

		if(logic.isWorking())
		{
			_mUnitUseLogicOnWorking.put(logic.index,logic);
		}
	}
	
	/// <summary>
	/// 移除角色战斗数据逻辑
	/// </summary>
	public void removeMUnitUseLogic(MUnitUseLogic logic)
	{
		if(logic.index==-1)
		{
			Ctrl.throwError("未就绪的MUnitUseLogic");
		}

		_mUnitUseLogics.remove(logic.index);

		if(logic.isWorking())
		{
			_mUnitUseLogicOnWorking.remove(logic.index);
		}
	}
	
	/// <summary>
	/// 获取主角单位使用数据(可能为空)
	/// </summary>
	public MUnitUseLogic getMUnitUseLogic(int index)
	{
		return _mUnitUseLogics.get(index);
	}
	
	/// <summary>
	/// 获取所有出战单位
	/// </summary>
	public IntObjectMap<MUnitUseLogic> getMUnitUseLogicOnWorking()
	{
		return _mUnitUseLogicOnWorking;
	}
	
	public virtual CharacterUseLogic getCurrentCharacterUseLogic()
	{
		return null;
	}
	
	/// <summary>
	/// 获取主角单位数据逻辑
	/// </summary>
	public MUnitFightDataLogic getMUnitFightDataLogic(int index)
	{
		return getMUnitUseLogic(index).getFightLogic();
	}
	
	/** 通过saveData初始化useData */
	private void initMUnitUseBySave(MUnitUseData uData,MUnitSaveData sData)
	{
		uData.mIndex=sData.mIndex;
		uData.id=sData.id;
		uData.equips=sData.equips;//引用传递
	}
	
	/// <summary>
	/// 构造character部分
	/// </summary>
	protected virtual void initCharacterUseBySave(CharacterUseData uData,CharacterSaveData sData)
	{

	}
	
	/// <summary>
	/// 通过保存数据，创建使用数据
	/// </summary>
	public CharacterUseData createCharacterUseDataBySaveData(CharacterSaveData saveData)
	{
		CharacterUseData data=GameC.factory.createCharacterUseData();
		data.initDefault();

		//1级
		data.level=me.role.getLevel();
		initMUnitUseBySave(data,saveData);
		initCharacterUseBySave(data,saveData);

		return data;
	}
	
	/// <summary>
	/// 通过保存数据初始化
	/// </summary>
	public void initCharacterUseLogicBySaveData(CharacterUseLogic logic,CharacterSaveData saveData,bool needFuncTool,bool needBindPlayer,bool isClientDrive)
	{
		CharacterUseData useData=createCharacterUseDataBySaveData(saveData);

		initUseLogicByUseData(logic,useData,needFuncTool,needBindPlayer,isClientDrive);

		if(saveData.cache!=null)
		{
			logic.getFightLogic().loadCache(saveData.cache);
		}
	}
	
	/// <summary>
	/// 通过保存数据初始化
	/// </summary>
	public virtual void initUseLogicByUseData(MUnitUseLogic logic,MUnitUseData useData,bool needFuncTool,bool needBindPlayer,bool isClientDrive)
	{
		//基础部分
		logic.init(useData,isClientDrive);

		if(needBindPlayer)
		{
			logic.setPlayer(me);
		}

		if(isClientDrive)
		{
			//补满血蓝
			logic.getAttributeLogic().fillHpMp();
			//刷属性
			logic.getAttributeLogic().refreshAttributes();
		}

		if(needFuncTool)
		{
			int funcID=logic.getMUnitFuncID(FunctionType.Equip);
			PlayerEquipContainerTool funcTool=toCreatePlayerEquipContainerTool(funcID);
			//互相绑定
			funcTool.setMUnitLogic(logic);
			logic.setEquipTool(funcTool);

			me.func.addFuncTool(funcTool,useData.equips);
		}
	}
	
	protected virtual PlayerEquipContainerTool toCreatePlayerEquipContainerTool(int funcID)
	{
		return new PlayerEquipContainerTool(funcID);
	}
	
	protected override BaseData createPartData()
	{
		return new CharacterPartData();
	}
	
	private void doEquipActions(MUnitUseLogic logic,PlayerEquipContainerTool tool,int slot,int[][] actions,bool isOn)
	{
		for(int i=0;i<actions.Length;++i)
		{
			doOneEquipAction(logic,tool,slot,i,actions[i],isOn);
		}
	}
	
	/// <summary>
	/// 执行单个装备方法
	/// </summary>
	protected void doOneEquipAction(MUnitUseLogic logic,PlayerEquipContainerTool tool,int slot,int index,int[] args,bool isOn)
	{
		switch(args[0])
		{
			case ItemEquipActionType.AddBuff:
			{
				if(!CommonSetting.isClientDriveLogic)
					return;

				if(isOn)
				{
					if(ShineSetting.openCheck)
					{
						BuffConfig buffConfig=BuffConfig.get(args[0]);

						if(buffConfig.keepType!=BuffKeepType.Online)
						{
							Ctrl.throwError("装备用buff的保存类型必须为Online");
						}
					}

					BuffData buffData=logic.getBuffLogic().addBuff(args[0],args[1]);
					//记录buffID
					tool.getBuffInstanceIDDic().put(slot << CommonSetting.buffActionIndexOff | index,buffData.instanceID);
				}
				else
				{
					int instanceID=tool.getBuffInstanceIDDic().remove(slot << CommonSetting.buffActionIndexOff | index);

					if(instanceID<=0)
					{
						Ctrl.errorLog("不该找不到buff instanceID");
					}
					else
					{
						logic.getBuffLogic().removeBuffByInstanceID(instanceID);
					}
				}
			}
				break;
			case ItemEquipActionType.AddSkill:
			{
				if(!CommonSetting.isClientDriveLogic)
					return;

				if(isOn)
				{
					logic.getFightLogic().addSkill(args[0],args[1]);
				}
				else
				{
					logic.getFightLogic().removeSkill(args[0]);
				}
			}
				break;
		}
	}
	
	/// <summary>
	/// 添加装备影响(单个装备)
	/// </summary>
	public void addEquipInfluence(MUnitUseLogic logic,PlayerEquipContainerTool tool,int slot,ItemData data)
	{
		if(CommonSetting.isClientDriveLogic)
		{
			logic.getAttributeLogic().addAttributes(data.config.baseAttributes);
		}

		doEquipActions(logic,tool,slot,data.config.equipActions,true);
	}
	
	/// <summary>
	/// 移除装备影响(单个装备)
	/// </summary>
	public void removeEquipInfluence(MUnitUseLogic logic,PlayerEquipContainerTool tool,int slot,ItemData data)
	{
		if(CommonSetting.isClientDriveLogic)
		{
			logic.getAttributeLogic().subAttributes(data.config.baseAttributes);
		}

		doEquipActions(logic,tool,slot,data.config.equipActions,false);
	}
	
	/// <summary>
	/// 获取一个可用的主单位序号
	/// </summary>
	public int getOneMUnitIndex()
	{
		// return ++_d.mUnitIndex;
		return 1;//TODO:写死1先
	}
	
	/// <summary>
	/// 新创建的保存数据
	/// </summary>
	protected void newCreateUseData(MUnitUseData useData)
	{
		useData.mIndex=getOneMUnitIndex();
		useData.equips=GameC.factory.createEquipContainerData();
		useData.equips.initDefault();

		int unitType=useData.getUnitType();

		foreach (EquipSlotTypeConfig v in EquipSlotTypeConfig.getDic())
		{
			if(v!=null && v.unitType==unitType)
			{
				if(v.isOpen)
				{
					//直接打开
					useData.equips.openSlots.add(v.id);
				}
			}
		}
	}
	
}
