using ShineEngine;

/// <summary>
/// 玩家(generated by shine)
/// </summary>
public class RolePart:PlayerBasePart
{
	/** 数据 */
	private RolePartData _d;
	
	/** 缓存角色显示数据 */
	private RoleShowData _selfRoleShowData;
	
	/// <summary>
	/// 货币上限组
	/// </summary>
	protected long[] _currenciesMax;
	
	public override void setData(BaseData data)
	{
		base.setData(data);
		
		_d=(RolePartData)data;
	}
	
	/// <summary>
	/// 获取数据
	/// </summary>
	public RolePartData getPartData()
	{
		return _d;
	}
	
	/// <summary>
	/// 构造函数(只在new后调用一次,再次从池中取出不会调用)
	/// </summary>
	public override void construct()
	{
		//角色ID赋值
		_selfRoleShowData=GameC.factory.createRoleShowData();
	}
	
	/// <summary>
	/// 构造数据前
	/// </summary>
	protected override void beforeMakeData()
	{
		
	}
	
	/// <summary>
	/// 初始化(创建后刚调用,与dispose成对)
	/// </summary>
	public override void init()
	{
		
	}
	
	/// <summary>
	/// 析构(回池前调用,与init成对)
	/// </summary>
	public override void dispose()
	{
		for(int i=0;i<_currenciesMax.Length;++i)
		{
			_currenciesMax[i]=0;
		}
	}
	
	/// <summary>
	/// 从库中读完数据后(做数据的补充解析)(onNewCreate后也会调用一次)(主线程)
	/// </summary>
	public override void afterReadData()
	{
		_d.currencies=ObjectUtils.ensureArrayLength(_d.currencies,CurrencyType.size);
		_d.currenciesMax=ObjectUtils.ensureArrayLength(_d.currenciesMax,CurrencyType.size);

		_currenciesMax=_d.currenciesMax;
	}
	
	/// <summary>
	/// 每秒调用
	/// </summary>
	public override void afterReadDataSecond()
	{
		makeRoleShowData(_selfRoleShowData);
	}
	
	/// <summary>
	/// 功能开启(id:功能ID)
	/// </summary>
	public override void onFunctionOpen(int id)
	{

	}
	
	/// <summary>
	/// 功能关闭(id:功能ID)
	/// </summary>
	public override void onFunctionClose(int id)
	{

	}
	
	public override void onNewCreate()
	{

		_d.level=1;
		_d.exp=0L;

		_d.currencies=new long[CurrencyType.size];
		_d.totalAddCurrencies=new long[CurrencyType.size];
		_currenciesMax=new long[CurrencyType.size];

		InitCreateConfig config=InitCreateConfig.get(_d.vocation);

		if(config!=null)
		{
			foreach (DIntData v  in config.currency)
			{
				addCurrency(v.key,v.value,CallWayType.InitCreate);
			}
		}
		else
		{
			Ctrl.warnLog("未找到角色初始化配置,vocation:",_d.vocation);
		}
	}
	
	/// <summary>
	/// 执行创建角色(逻辑相关)
	/// </summary>
	public virtual void doCreatePlayer(CreatePlayerData data)
	{
		_d.sex=data.sex;
		_d.vocation=data.vocation;
	}
	
	/// <summary>
	/// 角色ID
	/// </summary>
	public long playerID
	{
		get {return _d.playerID;}
	}
	
	/// <summary>
	/// 账号id
	/// </summary>
	public string uid
	{
		get {return _d.uid;}
	}
	
	/// <summary>
	/// 名字
	/// </summary>
	public string name
	{
		get {return _d.name;}
	}
	
	/// <summary>
	/// 职业
	/// </summary>
	public int vocation
	{
		get {return _d.vocation;}
	}
	
	/// <summary>
	/// 等级
	/// </summary>
	public int level
	{
		get {return _d.level;}
	}
	
	/// <summary>
	/// 等级
	/// </summary>
	public int getLevel()
	{
		return _d.level;
	}
	
	/// <summary>
	/// 构造角色展示数据
	/// </summary>
	public virtual void makeRoleShowData(RoleShowData data)
	{
		data.playerID=playerID;
		data.createAreaID=_d.createAreaID;
		data.name=_d.name;

		data.sex=_d.sex;
		data.level=_d.level;
		data.vocation=_d.vocation;
	}
	
	/// <summary>
	/// 构造角色简版展示数据
	/// </summary>
	public virtual void makeRoleSimpleShowData(RoleSimpleShowData data)
	{
		data.playerID=playerID;
		data.createAreaID=_d.createAreaID;
		data.name=_d.name;

		data.sex=_d.sex;
		data.vocation=_d.vocation;
	}
	
	/// <summary>
	/// 创建角色展示数据
	/// </summary>
	public RoleShowData createRoleShowData()
	{
		RoleShowData data=GameC.factory.createRoleShowData();
		makeRoleShowData(data);
		return data;
	}
	
	/// <summary>
	/// 获取缓存角色展示数据(当前线程用)
	/// </summary>
	public RoleShowData getSelfRoleShowData()
	{
		return _selfRoleShowData;
	}
	
	/// <summary>
	/// 创建角色展示数据
	/// </summary>
	public RoleSimpleShowData createRoleSimpleShowData()
	{
		RoleSimpleShowData data=GameC.factory.createRoleSimpleShowData();
		makeRoleSimpleShowData(data);
		return data;
	}
	
	/// <summary>
	/// 是否拥有货币组
	/// </summary>
	public bool hasCurrencies(DIntData[] list,int num=1)
	{
		foreach(DIntData v in list)
		{
			if(!hasCurrency(v.key,v.value*num))
				return false;
		}

		return true;
	}
	
	/// <summary>
	/// 是否有足够货币
	/// </summary>
	public bool hasCurrency(int type,long value)
	{
		if(value<0)
			return false;

		return _d.currencies[type] >= value;
	}
	
	/// <summary>
	/// 添加货币上限值
	/// </summary>
	public void addCurrencyMax(int type,long value)
	{
		_currenciesMax[type]+=value;
	}
	
	/// <summary>
	/// 减少货币上限值
	/// </summary>
	public void subCurrencyMax(int type,long value)
	{
		_currenciesMax[type]-=value;
	}
	
	/// <summary>
	/// 货币是否到达上限
	/// </summary>
	public bool isCurrencyMax(int type)
	{
		long max;
		return (max=_currenciesMax[type])>0 && _d.currencies[type]>=max;
	}
	
	/// <summary>
	/// 添加货币(只能加不能减)(客户端驱动模式下)
	/// </summary>
	public void addCurrency(int type,long value,int way)
	{
		addCurrency(type,value,way,false);
	}
	
	/// <summary>
	/// 添加货币(只能加不能减)(可破上限)(客户端驱动模式下)
	/// </summary>
	public void addCurrencyAbs(int type,long value,int way)
	{
		addCurrency(type,value,way,true);
	}
	
	/// <summary>
	/// 添加货币(只能加不能减)(客户端驱动模式下)
	/// </summary>
	public void addCurrency(int type,long value,int way,bool isAbs)
	{
		if(value<=0)
			return;

		if(value<=0)
			return;

		long now=_d.currencies[type];

		if(!isAbs || !CurrencyConfig.get(type).canOverMaxByAbs)
		{
			long max;

			if((max=_currenciesMax[type])>0)
			{
				//达到上限
				if(now>=max)
				{
					return;
				}

				//本次可加值
				if(now+value>=max)
				{
					value=max-now;
				}
			}
		}

		now=(_d.currencies[type]+=value);

		toLogAddCurrency(type,value,way);

		me.dispatch(GameEventType.RefreshCurrency,type);

		//需要增加记录
		if(CommonSetting.isClientDriveLogic && CurrencyConfig.get(type).needAddRecord)
		{
			int v2=(int)(_d.totalAddCurrencies[type]+=value);

			me.quest.taskEvent(TaskType.TotalAddCurrency,type,v2);
		}
		
		onAddCurrency(type,value);
	}
	
	/// <summary>
	/// 添加货币组
	/// </summary>
	public void addCurrencies(DIntData[] list,int way)
	{
		foreach(DIntData v in list)
		{
			addCurrency(v.key,v.value,way);
		}
	}
	
	/// <summary>
	/// 添加货币组
	/// </summary>
	public void addCurrenciesAbs(DIntData[] list,int num,int way)
	{
		foreach(DIntData v in list)
		{
			addCurrency(v.key,v.value*num,way,true);
		}
	}
	
	/// <summary>
	/// 获取货币
	/// </summary>
	public long getCurrency(int type)
	{
		return _d.currencies[type];
	}
	
	/// <summary>
	/// 消耗货币
	/// </summary>
	public void costCurrency(int type,long value,int way)
	{
		if(value<=0)
			return;

		long[] currencies;

		long v=(currencies=_d.currencies)[type];

		if((v-=value)<0)
		{
			value=v;
			v=0;
		}

		currencies[type]=v;

		toLogCostCurrency(type,value,way);

		me.dispatch(GameEventType.RefreshCurrency,type);

		if(CommonSetting.isClientDriveLogic && CurrencyConfig.get(type).needAddRecord)
		{
			me.quest.taskEvent(TaskType.TotalCostCurrency,type,(int)(_d.totalAddCurrencies[type]-_d.currencies[type]));
		}

		onCostCurrency(type,value);
	}
	
	/// <summary>
	/// 消耗货币组
	/// </summary>
	public bool costCurrencies(DIntData[] list,int num,int way)
	{
		if(!hasCurrencies(list,num))
			return false;

		foreach(DIntData v in list)
		{
			costCurrency(v.key,v.value*num,way);
		}

		return true;
	}
	
	/// <summary>
	/// 刷新货币
	/// </summary>
	public void onRefreshCurrency(int type,long value)
	{
		_d.currencies[type] = value;
		//改完值再去刷新
		toRefreshCurrency(type,value);
		me.dispatch(GameEventType.RefreshCurrency,type);
	}
	
	/// <summary>
	/// 添加经验
	/// </summary>
	public void addExp(long value,int way)
	{
		if(value<=0)
			return;

		int level;
		//已达最大等级
		if((level=_d.level) >= Global.levelMax)
		{
			return;
		}

		long v=(_d.exp+=value);

		long expMax;

		if(v >= (expMax=RoleLevelConfig.get(level).expMax))
		{
			int oldLevel=level;

			while(true)
			{
				v-=expMax;

				if(++level == Global.levelMax)
				{
					v=0;

					break;
				}

				expMax=RoleLevelConfig.get(level).expMax;

				if(v<expMax)
					break;
			}

			onRefreshExp(v);

			_d.level=level;

			me.onLevelUp(oldLevel);
		}
		else
		{
			onRefreshExp(v);
		}
	}
	
	/// <summary>
	/// 刷新经验
	/// </summary>
	public void onRefreshExp(long value)
	{
		_d.exp = value;
		me.dispatch(GameEventType.RefreshExp);
	}
	
	public override void onLevelUp(int oldLevel)
	{
		me.dispatch(GameEventType.RoleLevelUp,oldLevel);

		me.quest.taskEvent(TaskType.Level);

		me.quest.questConditionChanged();
	}
	
	/// <summary>
	/// 升级消息
	/// </summary>
	public void levelUpByServer(int level)
	{
		int oldLevel = _d.level;
		_d.level = level;
		me.onLevelUp(oldLevel);
	}
	
	/// <summary>
	/// 更改名字消息
	/// </summary>
	public void onChangeName(string name)
	{
		_d.name=name;
		me.dispatch(GameEventType.RoleChangeName);
	}
	
	/// <summary>
	/// 添加货币日志(可复写做过滤)
	/// </summary>
	protected virtual void toLogAddCurrency(int type,long value,int way)
	{
		GameC.log.playerAddCurrency(me,type,value,way);
	}
	
	/// <summary>
	/// 消耗货币记录(可复写做过滤)
	/// </summary>
	protected virtual void toLogCostCurrency(int type,long value,int way)
	{
		GameC.log.playerCostCurrency(me,type,value,way);
	}
	
	/// <summary>
	/// 添加货币接口
	/// </summary>
	protected virtual void onAddCurrency(int type,long value)
	{

	}
	
	/// <summary>
	/// 添加货币接口
	/// </summary>
	protected virtual void onCostCurrency(int type,long value)
	{

	}
	
	/// <summary>
	/// 货币刷新接口
	/// </summary>
	protected virtual void toRefreshCurrency(int type,long value)
	{

	}
	
	/// <summary>
	/// 申请绑定平台
	/// </summary>
	public void applyBindPlatform(string uid,string platform)
	{
		if(_d.platform!=PlatformType.Visitor)
		{
			me.warnLog("游客平台不能绑定");
			return;
		}

		if(platform==PlatformType.Visitor)
		{
			me.warnLog("游客平台不能绑定");
			return;
		}

		ApplyBindPlatformRequest.create(uid,platform).send();
	}
	
	/// <summary>
	/// 绑定平台结果
	/// </summary>
	public virtual void onBindPlatform(string uid,string platform)
	{
		if(!CommonSetting.UserNeedMultiPlatformBind)
		{
			_d.uid=uid;
			_d.platform=platform;
			
			GameC.save.saveByBindPlatform(uid,platform);
			GameC.main.refreshLoginData(uid,platform);
		}
		
		me.dispatch(GameEventType.BindPlatformSuccess,platform);
	}
	
	protected override BaseData createPartData()
	{
		return new RolePartData();
	}
	
	/// <summary>
	/// 刷新部分外显数据(int)
	/// </summary>
	public void refreshPartRoleShowData(int type,int value)
	{
		RoleShowChangeData data=new RoleShowChangeData();
		data.type=type;
		data.arg0=value;

		refreshPartRoleShowData(data);
	}
	
	/// <summary>
	/// 刷新部分外显数据(String)
	/// </summary>
	public void refreshPartRoleShowData(int type,string value)
	{
		RoleShowChangeData data=new RoleShowChangeData();
		data.type=type;
		data.arg1=value;

		refreshPartRoleShowData(data);
	}
	
	/// <summary>
	/// 刷新部分外显数据
	/// </summary>
	public void refreshPartRoleShowData(RoleShowChangeData data)
	{
		//先改自己的
		_selfRoleShowData.onChange(data);

		Scene scene=GameC.scene.getScene();

		//场景部分
		Unit unit;

		if(scene!=null && (unit=scene.hero)!=null)
		{
			//非社交部分
			if(!RoleShowDataPartTypeConfig.get(data.type).isSocialPart)
			{
				RoleShowData roleShowData=unit.getUnitData().getCharacterIdentity().roleShowData;

				roleShowData.onChange(data);
			}
		}

		//社交部分
		// me.social.refreshRoleSocialData(data);
	}
	
	/// <summary>
	/// 更新战斗力(服务器)
	/// </summary>
	public void onSetFightForceBeServer(long value)
	{
		_d.fightForce=value;

		me.dispatch(GameEventType.RefreshFightForce);
	}
	
	/// <summary>
	/// 获取战斗力
	/// </summary>
	public long getFightForce()
	{
		return _d.fightForce;
	}
	
	/// <summary>
	/// 检查角色条件一组
	/// </summary>
	public bool checkRoleConditions(int[][] args,bool needNotice)
	{
		foreach(int[] v in args)
		{
			if(!checkOneRoleCondition(v,needNotice))
			{
				return false;
			}
		}

		return true;
	}
	
	/// <summary>
	/// 检查单个角色条件
	/// </summary>
	public virtual bool checkOneRoleCondition(int[] args,bool needNotice)
	{
		switch(args[0])
		{
			case RoleConditionType.Level:
			{
				if(me.role.getLevel()<args[1])
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_needLevel);

					return false;
				}
			}
				break;
			case RoleConditionType.FunctionOpen:
			{
				if(!me.func.isFunctionOpen(args[1]))
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_functionNotOpen,FunctionConfig.get(args[1]).showName);

					return false;
				}
			}
				break;
			case RoleConditionType.NeedUnion:
			{
				if(!me.union.hasUnion())
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_needUnion);

					return false;
				}
			}
				break;
			case RoleConditionType.QuestComplete:
			{
				if(!me.quest.isQuestComplete(args[1]))
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_needCompleteQuest,QuestConfig.get(args[1]).name);

					return false;
				}
			}
				break;
			case RoleConditionType.OnStatus:
			{
				if(!me.character.getCurrentCharacterUseLogic().getFightLogic().status.getStatus(args[1]))
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_needOnStatus,StatusConfig.getShowName(args[1]));

					return false;
				}
			}
				break;
			case RoleConditionType.OffStatus:
			{
				if(me.character.getCurrentCharacterUseLogic().getFightLogic().status.getStatus(args[1]))
				{
					if(needNotice)
						me.showInfoCode(InfoCodeType.Condition_needOffStatus,StatusConfig.getShowName(args[1]));

					return false;
				}
			}
				break;
		}

		return true;
	}
	
	/// <summary>
	/// 执行动作组
	/// </summary>
	public void doRoleActions(int[][] actions,int num,int way)
	{
		if(!CommonSetting.isClientDriveLogic)
			return;

		foreach(int[] v in actions)
		{
			me.role.doOneRoleAction(v,num,way);
		}
	}
	
	/// <summary>
	/// 执行单个动作
	/// </summary>
	public virtual void doOneRoleAction(int[] args,int num,int way)
	{
		if(!CommonSetting.isClientDriveLogic)
			return;

		switch(args[0])
		{
			case RoleActionType.HeroAddAttribute:
			{
				CharacterUseLogic logic;

				if((logic=me.character.getCurrentCharacterUseLogic())!=null)
				{
					logic.getAttributeLogic().addOneAttribute(args[1],args[2]*num);
				}
			}
				break;
			case RoleActionType.HeroAddAttributeVar:
			{
				CharacterUseLogic logic;

				if((logic=me.character.getCurrentCharacterUseLogic())!=null)
				{
					logic.getAttributeLogic().addOneAttribute(args[1],logic.getFightLogic().getSkillVarValue(args[2])*num);
				}
			}
				break;
			case RoleActionType.HeroAddBuff:
			{
				CharacterUseLogic logic;

				if((logic=me.character.getCurrentCharacterUseLogic())!=null)
				{
					logic.getBuffLogic().addBuff(args[1],args[2]);//buff只加一次
				}
			}
				break;
			case RoleActionType.AddCurrency:
			{
				me.role.addCurrency(args[1],args[2]*num,way);
			}
				break;
			case RoleActionType.AddReward:
			{
				for(int i=0;i<num;++i)
				{
					me.bag.addReward(args[1],way);
				}
			}
				break;
			case RoleActionType.RemoveItem:
			{
				//通过物品id和数量移除道具
				me.bag.removeItem(args[1],args[2]*num,way);
			}
				break;
		}
	}
	
	/// <summary>
	/// 执行单个道具物品动作
	/// </summary>
	public virtual bool checkOneRoleConditionForAction(int[] args,int num)
	{
		switch(args[0])
		{
			case RoleActionType.AddReward:
			{
				RewardConfig rewardConfig=RewardConfig.get(args[1]);
				//只看空余格子
				return me.bag.hasFreeGrid(rewardConfig.needGrid*num);
			}
		}

		return true;
	}
	
}
